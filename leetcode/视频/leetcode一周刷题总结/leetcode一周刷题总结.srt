1
00:00:02,566 --> 00:00:03,300
hello大家好

2
00:00:03,300 --> 00:00:06,666
我是Leo然后今天这个星期

3
00:00:06,666 --> 00:00:10,533
呃我在5个工作日

4
00:00:10,533 --> 00:00:12,966
然后完成了5道的legal题

5
00:00:13,166 --> 00:00:15,100
然后我打算用周六周日

6
00:00:15,100 --> 00:00:17,066
来总结一下这5道题

7
00:00:17,900 --> 00:00:20,266
然后让这个练习的效率

8
00:00:20,266 --> 00:00:22,966
呃尽可能的高然后

9
00:00:24,333 --> 00:00:25,333
首先第一道题呢

10
00:00:25,333 --> 00:00:27,933
就是那个两数之之和

11
00:00:28,266 --> 00:00:29,366
然后啊呃

12
00:00:29,366 --> 00:00:30,000
一般来讲

13
00:00:30,000 --> 00:00:30,866
会写hello world

14
00:00:30,866 --> 00:00:34,333
的人一般都是可以做出这道题

15
00:00:34,333 --> 00:00:36,666
就是直接暴力法是吧

16
00:00:36,666 --> 00:00:37,133
暴力法

17
00:00:37,133 --> 00:00:40,933
直接写就两个数加起来就完事了是吧

18
00:00:41,300 --> 00:00:42,100
然后

19
00:00:43,533 --> 00:00:44,100
主要是

20
00:00:44,100 --> 00:00:47,900
这题他肯定是有有关一个性能的

21
00:00:48,333 --> 00:00:50,300
就是你像比如说呃

22
00:00:50,533 --> 00:00:54,933
一些企业给你一个去呃应面试

23
00:00:54,933 --> 00:00:56,366
然后他给你这道题

24
00:00:56,366 --> 00:00:57,800
你直接暴力写出来了

25
00:00:57,800 --> 00:00:58,966
你觉得你做出来了

26
00:00:58,966 --> 00:01:02,300
但是实际上可能你的性能并不高

27
00:01:02,366 --> 00:01:03,966
那可可能别人pass掉你

28
00:01:03,966 --> 00:01:04,766
你还不知道

29
00:01:04,766 --> 00:01:07,766
其实所以说就是呃刷立扣

30
00:01:07,766 --> 00:01:09,933
我觉得还是非常有用的

31
00:01:10,666 --> 00:01:13,200
然后呃这个答案就是说

32
00:01:13,200 --> 00:01:15,900
这道题答案就是用C++里面的哈西表

33
00:01:15,966 --> 00:01:18,000
然后可以找到这个数组

34
00:01:18,000 --> 00:01:19,800
里面存在的一个元素

35
00:01:20,100 --> 00:01:22,566
然后就进而减少时间复杂度

36
00:01:22,866 --> 00:01:24,300
而这个是怎么理解的呢

37
00:01:24,300 --> 00:01:25,466
就说你会觉得哦

38
00:01:26,366 --> 00:01:28,733
计算机找哈西表里面的值

39
00:01:28,800 --> 00:01:30,600
不也得搜索吗

40
00:01:30,866 --> 00:01:34,800
那那数组的话不是不也是要便利吗

41
00:01:34,800 --> 00:01:36,566
这两个搜索有什么区别

42
00:01:37,533 --> 00:01:40,300
嗯因为哈西表里面的键值

43
00:01:40,300 --> 00:01:41,600
就是对于电脑来说

44
00:01:41,600 --> 00:01:45,300
是可以直接通过key找到value

45
00:01:45,300 --> 00:01:46,300
就像于电脑

46
00:01:46,400 --> 00:01:47,666
电脑找呃就是这

47
00:01:47,666 --> 00:01:48,533
在这个嗨起表里面

48
00:01:48,533 --> 00:01:49,600
电脑找这个key

49
00:01:50,133 --> 00:01:52,400
是直接可以一眼找出来的

50
00:01:53,066 --> 00:01:54,100
他就相当于人一样

51
00:01:54,100 --> 00:01:55,500
一二给你10个

52
00:01:55,500 --> 00:01:58,133
呃给你嗯多少多少个数

53
00:01:58,133 --> 00:01:59,100
给你5个数

54
00:01:59,166 --> 00:02:01,066
让你指出来3在哪里

55
00:02:01,200 --> 00:02:02,100
那可以一下

56
00:02:02,100 --> 00:02:02,900
就指出来对不对

57
00:02:02,900 --> 00:02:04,266
不用从一开始数

58
00:02:04,966 --> 00:02:06,733
跟电脑来说也是一个道理

59
00:02:06,800 --> 00:02:08,900
然后所以说时间复杂度是一

60
00:02:08,900 --> 00:02:13,166
但是嗯他的他他他见表的时候

61
00:02:13,166 --> 00:02:15,700
他是呃需要o n的

62
00:02:16,133 --> 00:02:20,166
所以说就是如果说你有涉及到多重签

63
00:02:20,166 --> 00:02:21,466
到循环的时候

64
00:02:21,566 --> 00:02:23,366
你就可以建一个哈西表

65
00:02:23,366 --> 00:02:24,766
来减少时间复杂度

66
00:02:24,766 --> 00:02:27,533
可以让它最小最小减到o n

67
00:02:27,666 --> 00:02:28,966
就是这样的一个道理

68
00:02:29,733 --> 00:02:31,866
然后数组的话就是要便利嘛

69
00:02:32,266 --> 00:02:34,466
对就大概是这样的一个意思

70
00:02:34,466 --> 00:02:36,700
就这第一题给我的一个感悟

71
00:02:37,400 --> 00:02:38,566
这个是很重要的

72
00:02:40,300 --> 00:02:42,133
然后第二题就是两数相加

73
00:02:42,133 --> 00:02:43,000
两数相加

74
00:02:43,000 --> 00:02:46,566
也是跟这个两数之和是一样的

75
00:02:46,566 --> 00:02:48,766
是不是你会觉得那两数相加

76
00:02:48,766 --> 00:02:51,900
它就涉及到它是一个简单一个中等

77
00:02:51,900 --> 00:02:54,166
两数相加就涉及到了一个链表

78
00:02:55,200 --> 00:02:56,733
并且是两个非公链表

79
00:02:56,733 --> 00:02:58,900
然后表表示两个非负的整数

80
00:02:59,400 --> 00:03:01,266
然后按逆序的方式存储

81
00:03:01,366 --> 00:03:02,933
你要知道逆序是什么意思

82
00:03:02,933 --> 00:03:04,400
逆序就是说呃

83
00:03:05,466 --> 00:03:07,500
就是从从尾到头啊

84
00:03:07,500 --> 00:03:10,866
列表的尾到头那头一般都是指针

85
00:03:10,866 --> 00:03:11,933
指针的地方

86
00:03:12,866 --> 00:03:15,600
然后跟人的其实阅读习惯是一样的

87
00:03:16,300 --> 00:03:20,066
然后纯因位数值就导致了一个呃

88
00:03:20,066 --> 00:03:22,366
相当于计算器的要考虑进位嘛

89
00:03:22,933 --> 00:03:24,133
那如果是两数

90
00:03:24,366 --> 00:03:27,933
两数相两数相加并且相减

91
00:03:28,066 --> 00:03:30,966
那你还得考虑一个退位啊

92
00:03:30,966 --> 00:03:31,900
好了本质上

93
00:03:31,900 --> 00:03:33,966
就是一个计算器的一个位运算啊

94
00:03:33,966 --> 00:03:36,000
并且只需要考虑进位啊

95
00:03:36,000 --> 00:03:37,366
不啊我那时候不足呢

96
00:03:37,366 --> 00:03:38,500
因为是第二天做

97
00:03:38,500 --> 00:03:40,000
然后就是不知道的

98
00:03:40,000 --> 00:03:41,966
一个指针列表的一个操作

99
00:03:42,166 --> 00:03:44,366
然后他这这道题就是要考虑两个点嘛

100
00:03:44,366 --> 00:03:45,600
一个就是进位

101
00:03:45,766 --> 00:03:48,133
然后还有一个就是列表为浪的时候

102
00:03:48,133 --> 00:03:48,966
需要补灵

103
00:03:49,200 --> 00:03:51,466
这个情况可能是

104
00:03:51,466 --> 00:03:54,133
遍布在几乎每道题就

105
00:03:54,133 --> 00:03:55,266
所以说你练的越多

106
00:03:55,266 --> 00:03:56,800
你对这个东西就越敏感

107
00:03:56,800 --> 00:03:58,200
你像我一开始的时候我

108
00:03:58,400 --> 00:04:00,933
我是没有这种意识的

109
00:04:00,933 --> 00:04:01,733
所以说

110
00:04:02,500 --> 00:04:03,900
嗯还是要多刷题

111
00:04:04,200 --> 00:04:07,200
然后我做这道题的感悟就是说

112
00:04:07,200 --> 00:04:09,800
外循环是比较适合链表的一个操作

113
00:04:09,866 --> 00:04:12,000
以后看到链表就想到外循环

114
00:04:12,500 --> 00:04:14,466
然后链指针的操作呢

115
00:04:15,666 --> 00:04:17,333
往往都需要考虑释放

116
00:04:17,566 --> 00:04:20,900
这个是一个非常非常严呃

117
00:04:20,900 --> 00:04:22,366
就是很重要的一个细节

118
00:04:22,366 --> 00:04:23,933
因为你

119
00:04:24,166 --> 00:04:26,933
你到时候面试的时候比面试官也是会

120
00:04:27,266 --> 00:04:28,666
就是这点看的

121
00:04:29,166 --> 00:04:31,800
要不然你写你你写

122
00:04:31,800 --> 00:04:33,366
写了一个13出来

123
00:04:33,366 --> 00:04:35,866
那以后那一出来

124
00:04:35,866 --> 00:04:37,700
别人还得给你拍bug是吧

125
00:04:38,100 --> 00:04:39,666
并且现在这么这么卷的话

126
00:04:39,666 --> 00:04:41,366
你要注意这些细节

127
00:04:44,366 --> 00:04:44,933
然后第三题

128
00:04:44,933 --> 00:04:49,466
就是一个无重复字符的一个最长指串

129
00:04:50,666 --> 00:04:52,866
要写出一个不含重复字符

130
00:04:52,866 --> 00:04:54,733
最长指串的一个长度

131
00:04:55,066 --> 00:04:56,000
要算长度

132
00:04:56,300 --> 00:04:59,166
最长指串没有重复字符啊

133
00:04:59,166 --> 00:05:01,333
一看到就可以想到一个解法

134
00:05:01,333 --> 00:05:05,066
是吧看到这题就是嗯

135
00:05:05,866 --> 00:05:06,533
但是我

136
00:05:06,533 --> 00:05:09,866
我那时候就是没有考虑到有滑动窗口

137
00:05:09,866 --> 00:05:11,733
这个呃因素

138
00:05:11,733 --> 00:05:13,333
然后就一开始写错了

139
00:05:13,333 --> 00:05:17,466
然后后面并且还是便利的时候

140
00:05:17,466 --> 00:05:18,733
还用了双重循环

141
00:05:18,733 --> 00:05:20,066
时间复杂度太高

142
00:05:20,066 --> 00:05:24,100
你看直接就call back第一题

143
00:05:24,400 --> 00:05:27,066
那第一题得到的一个感悟

144
00:05:27,100 --> 00:05:30,300
用了第三题来直接用哈系表

145
00:05:30,300 --> 00:05:32,400
是不是直接可以减少时间复杂度

146
00:05:32,466 --> 00:05:35,400
双重循环时间复杂度o n的平方

147
00:05:35,933 --> 00:05:38,933
那用哈系表就可以变成o n对吧

148
00:05:39,800 --> 00:05:40,866
这个也是要

149
00:05:42,533 --> 00:05:43,800
很就是很重要的

150
00:05:45,133 --> 00:05:46,100
然后第四题呢

151
00:05:46,100 --> 00:05:48,866
第四题这个是为什么他这题写困难

152
00:05:49,266 --> 00:05:50,600
前面三题都是中等

153
00:05:51,300 --> 00:05:52,900
因为他的解法太多了

154
00:05:52,966 --> 00:05:54,800
然后时间

155
00:05:54,800 --> 00:05:57,800
复杂度要求是o log m加n

156
00:05:59,500 --> 00:06:02,466
它这个log就是它本质上呃

157
00:06:02,466 --> 00:06:05,966
就是两两个正序数组的一个中位数嘛

158
00:06:06,300 --> 00:06:08,333
找中位数本质上就个排序嘛

159
00:06:08,566 --> 00:06:10,100
中位数就排中间的一个数嘛

160
00:06:10,100 --> 00:06:10,900
就排序

161
00:06:11,200 --> 00:06:13,900
然后一开始就看到就想到一个

162
00:06:13,900 --> 00:06:14,766
用暴力法嘛

163
00:06:14,766 --> 00:06:17,600
把开头两个数比较大小就行了对吧

164
00:06:17,900 --> 00:06:21,666
然后判定各种情况的话就是边界嘛

165
00:06:21,766 --> 00:06:22,966
什么什么的对吧

166
00:06:23,700 --> 00:06:26,166
我就是直接用暴力法解了就是

167
00:06:26,166 --> 00:06:27,666
但是你你想到中位

168
00:06:27,666 --> 00:06:30,400
看到中位数首先一个就是

169
00:06:30,400 --> 00:06:32,533
至少就是需要对吧

170
00:06:32,533 --> 00:06:33,500
就是规避吗

171
00:06:33,500 --> 00:06:35,200
是吧或者说二分法

172
00:06:35,366 --> 00:06:39,700
以后看到中位数就想到要二分法

173
00:06:40,300 --> 00:06:41,400
他规避的话

174
00:06:43,000 --> 00:06:46,000
规并的话得到两个最大数组中位数

175
00:06:46,000 --> 00:06:48,333
它时间复杂度是m加n

176
00:06:48,333 --> 00:06:51,200
它不满足这个log那

177
00:06:51,200 --> 00:06:52,466
至于规并法呃

178
00:06:52,466 --> 00:06:57,066
这个可能明天我再嗯详细的讲一下

179
00:06:57,400 --> 00:06:59,800
为什么时间复杂度是o m加n

180
00:07:00,066 --> 00:07:02,333
然后空间复杂度也是o m加n

181
00:07:03,066 --> 00:07:04,566
然后呢还有第二种方法

182
00:07:04,566 --> 00:07:06,466
就是维护两个指针

183
00:07:06,600 --> 00:07:09,266
直到找到中位数就直接移嘛

184
00:07:09,400 --> 00:07:11,000
比较再移再比较

185
00:07:11,533 --> 00:07:13,066
空间复杂度可以降为一

186
00:07:13,100 --> 00:07:15,266
但是时间复杂度还是没变

187
00:07:16,066 --> 00:07:19,000
然后为了要达到这种log的情况呢

188
00:07:19,000 --> 00:07:22,733
log m加n它应该为log m加n

189
00:07:23,000 --> 00:07:25,366
那你就可以就是用二分查找

190
00:07:25,366 --> 00:07:27,266
为什么二分查找就是log呢

191
00:07:27,866 --> 00:07:31,666
因为它只用比较嗯2的指数次方式

192
00:07:32,000 --> 00:07:34,733
然后就是时间w就是2LOG啦

193
00:07:36,533 --> 00:07:38,200
然后它的这个原理是什么

194
00:07:38,200 --> 00:07:40,000
因为你是有序加递增

195
00:07:40,000 --> 00:07:41,166
以两个条件

196
00:07:41,600 --> 00:07:42,300
你不可以

197
00:07:42,300 --> 00:07:43,200
他你两个条件

198
00:07:43,200 --> 00:07:44,933
应该是可以解除两个未知数的

199
00:07:44,933 --> 00:07:47,333
嘛两个条件可以解除两个未知数

200
00:07:47,333 --> 00:07:51,100
那你就不能只用只用这两个条件

201
00:07:51,100 --> 00:07:52,866
去解除一个东西来

202
00:07:53,466 --> 00:07:54,266
就是就是

203
00:07:54,266 --> 00:07:55,566
你看前面的他就是

204
00:07:55,566 --> 00:07:58,666
只是排序面是正序数组

205
00:07:58,666 --> 00:08:00,333
就可以知道他是最小的

206
00:08:00,333 --> 00:08:02,266
用最小的来比较

207
00:08:02,266 --> 00:08:02,866
是不是

208
00:08:02,866 --> 00:08:04,933
我不仅要比较我还要比较他是

209
00:08:04,933 --> 00:08:06,800
我还要知道他是第几大的

210
00:08:07,533 --> 00:08:10,266
是吧可以用这个知道他是第几大的

211
00:08:10,800 --> 00:08:13,133
这里面有个比较抽象的东西

212
00:08:13,133 --> 00:08:14,100
我突然想到

213
00:08:14,100 --> 00:08:17,500
但是我也不知道该怎么说出来然后

214
00:08:19,166 --> 00:08:19,933
你先你看

215
00:08:19,933 --> 00:08:23,766
比如说呃要要求出DK大的一个数嘛

216
00:08:23,766 --> 00:08:26,100
你可以先减掉这个呃

217
00:08:26,100 --> 00:08:31,100
就是去掉那个k/2 -1 的一个数

218
00:08:31,900 --> 00:08:34,166
然后他们两个两个1/2 k

219
00:08:34,166 --> 00:08:36,100
二分之k减一的数一比较

220
00:08:36,666 --> 00:08:39,600
比如说那个2 1的一个数组

221
00:08:39,966 --> 00:08:42,600
比如说b的数组的二分之k减一

222
00:08:42,700 --> 00:08:45,133
这个数大于这个数

223
00:08:45,266 --> 00:08:47,666
那这个前面这些数是不是

224
00:08:49,300 --> 00:08:50,500
至少都是

225
00:08:52,133 --> 00:08:59,066
就比如说这这这个2至少是小于呃

226
00:09:00,600 --> 00:09:04,900
就是前面前面这些数至少就是呃要

227
00:09:07,166 --> 00:09:12,866
是D2分之就是比k减一还要小的

228
00:09:13,466 --> 00:09:13,866
懂我意思吗

229
00:09:13,866 --> 00:09:16,700
就是呃如果说你

230
00:09:16,966 --> 00:09:20,400
你这前面二分之k减一这个数

231
00:09:22,100 --> 00:09:23,800
就是你这个2至少是

232
00:09:28,700 --> 00:09:29,866
小于这个

233
00:09:31,066 --> 00:09:33,400
有假设就是说前面这些数都是

234
00:09:33,566 --> 00:09:37,600
就只有2是呃小于这个的嘛

235
00:09:37,666 --> 00:09:38,800
就只有20小于这个

236
00:09:38,800 --> 00:09:41,600
后面的数都是比这个比这个一大的

237
00:09:42,300 --> 00:09:44,200
他们就是在呃

238
00:09:45,933 --> 00:09:46,800
他他们两

239
00:09:46,800 --> 00:09:47,266
就比如说

240
00:09:47,266 --> 00:09:48,400
他们两个加起来

241
00:09:48,400 --> 00:09:51,200
就是二分之k减1+2分之k减1

242
00:09:51,500 --> 00:09:53,200
等于二分呃

243
00:09:53,200 --> 00:09:55,333
就是k减2嘛

244
00:09:55,400 --> 00:09:57,200
然后加上他们两个就是k了嘛

245
00:09:58,000 --> 00:10:01,700
那你假设他们他们他们都比他他们都

246
00:10:01,700 --> 00:10:04,000
比他小都比他小的话

247
00:10:04,000 --> 00:10:05,733
那就肯定是小于k的嘛

248
00:10:06,000 --> 00:10:07,533
就肯定不是DK个嘛

249
00:10:07,533 --> 00:10:09,900
所以就就把这前面的全部去掉了

250
00:10:10,400 --> 00:10:11,866
就大概这样的一个道理

251
00:10:12,100 --> 00:10:13,600
然后就之后呢

252
00:10:13,600 --> 00:10:16,766
然后再把再用这剩下的这些数组里

253
00:10:16,966 --> 00:10:19,200
然后再取那个二分的k减一

254
00:10:19,200 --> 00:10:20,566
然后再去掉那一半

255
00:10:21,166 --> 00:10:22,866
就是有二分法的一个道理

256
00:10:23,366 --> 00:10:24,566
然后要考虑三种

257
00:10:24,566 --> 00:10:25,600
一个特殊情况

258
00:10:25,600 --> 00:10:27,533
比如说二分法数组越界

259
00:10:28,000 --> 00:10:28,566
那什么意思

260
00:10:28,566 --> 00:10:30,600
就是说呃如果说

261
00:10:32,066 --> 00:10:33,700
你要取那个DK大的数

262
00:10:34,200 --> 00:10:37,733
然后你算那个二分之k减一的时候

263
00:10:38,066 --> 00:10:40,366
他这个a数组他不够了怎么办

264
00:10:40,566 --> 00:10:42,000
就是多退少补嘛

265
00:10:42,000 --> 00:10:45,300
就是你就取他最后一个数

266
00:10:45,966 --> 00:10:47,333
然后就是缺的

267
00:10:47,666 --> 00:10:49,566
就就就像k减掉嘛

268
00:10:50,066 --> 00:10:52,533
就是一般按正常情况来讲

269
00:10:52,533 --> 00:10:55,100
就直接是k等于k减二分之k

270
00:10:55,366 --> 00:10:56,333
但那种情况的话

271
00:10:56,333 --> 00:10:58,066
你可能要特殊考虑

272
00:10:59,000 --> 00:11:00,133
是一个特殊情况

273
00:11:00,133 --> 00:11:03,333
那这里为什么不是直接是二分之k呢

274
00:11:03,366 --> 00:11:07,000
因为呃这个二分之k就是在int类里

275
00:11:07,000 --> 00:11:09,866
类型里面二分之k它是向下曲整的嘛

276
00:11:09,866 --> 00:11:12,466
你可以减二分之k跟二分之k

277
00:11:12,466 --> 00:11:14,966
其实有些时候结果是不一样的

278
00:11:15,100 --> 00:11:16,300
比如说7/2

279
00:11:17,266 --> 00:11:17,966
结果是3

280
00:11:17,966 --> 00:11:20,333
对不啦那如果说啊

281
00:11:20,333 --> 00:11:23,466
k等于7 那二分之k结果就是3

282
00:11:23,733 --> 00:11:25,400
那7-二分之k

283
00:11:25,400 --> 00:11:26,600
那结果就是4

284
00:11:26,800 --> 00:11:29,133
所以说这两个是不一样的一个情况

285
00:11:29,400 --> 00:11:33,466
所以说他们就是要等于k减二分之k

286
00:11:33,466 --> 00:11:35,766
这也是一个非常非常小的一个细节

287
00:11:37,000 --> 00:11:38,366
然后第二个特殊情况

288
00:11:38,366 --> 00:11:40,100
就是另一个数值为空

289
00:11:40,400 --> 00:11:40,933
空了的话

290
00:11:40,933 --> 00:11:42,066
那就不用考虑了呗

291
00:11:42,066 --> 00:11:43,000
那直接把这个剩

292
00:11:43,000 --> 00:11:45,133
下数组那个嗯

293
00:11:45,866 --> 00:11:47,666
算出中间数就完事了呗

294
00:11:47,666 --> 00:11:49,733
然后k等于一的时候的意思就是说

295
00:11:49,933 --> 00:11:52,900
找b找找第一大的数

296
00:11:52,900 --> 00:11:54,533
那就直接两个数比较

297
00:11:54,733 --> 00:11:57,366
嗯谁大谁就是那个啥了对吧

298
00:11:58,700 --> 00:12:01,900
然后还有一种解法是一个划分数组

299
00:12:02,266 --> 00:12:03,200
它这个划分数组

300
00:12:03,200 --> 00:12:06,600
它的时间复杂度可以减到o的

301
00:12:07,100 --> 00:12:11,300
嗯log的m m

302
00:12:11,300 --> 00:12:13,000
或者m的最小值

303
00:12:13,066 --> 00:12:15,933
他他这个题目要求是log m加n嘛

304
00:12:16,300 --> 00:12:19,100
然后他这个划分数组还可以减到更小

305
00:12:19,600 --> 00:12:20,500
这个呃

306
00:12:20,500 --> 00:12:21,566
由于时间关系

307
00:12:21,566 --> 00:12:23,733
我还是明天再一起讲吧

308
00:12:23,733 --> 00:12:25,266
加上第5题

309
00:12:25,400 --> 00:12:26,600
现在只讲了4题

310
00:12:26,600 --> 00:12:28,766
然后第5题有很多种解法

311
00:12:28,900 --> 00:12:30,333
然后明天一起把它讲了

312
00:12:30,333 --> 00:12:31,766
还能够规避排序

313
00:12:32,200 --> 00:12:32,933
然后呃

314
00:12:32,933 --> 00:12:33,800
既然看到这里

315
00:12:33,800 --> 00:12:36,566
你应该也觉得呃

316
00:12:37,566 --> 00:12:39,600
如果说你们想要这份资料的话

317
00:12:39,600 --> 00:12:42,900
你们可以点赞投币三点关注

318
00:12:43,066 --> 00:12:46,733
然后我会私信发给你们这一份资料

319
00:12:46,966 --> 00:12:47,900
谢谢大家

