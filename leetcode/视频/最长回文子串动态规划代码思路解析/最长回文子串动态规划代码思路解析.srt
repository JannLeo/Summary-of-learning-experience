1
00:00:03,533 --> 00:00:04,600
今天做第5题

2
00:00:05,000 --> 00:00:05,933
第5题呃

3
00:00:05,933 --> 00:00:07,466
上次用暴力法没有做出来

4
00:00:07,466 --> 00:00:08,600
这次尝试一下

5
00:00:08,600 --> 00:00:10,066
用最基本的方法呃

6
00:00:10,066 --> 00:00:10,933
动态规划来做

7
00:00:11,166 --> 00:00:13,666
呃因为他一个最最长回纹子串呢

8
00:00:13,666 --> 00:00:14,200
它就是

9
00:00:14,500 --> 00:00:16,700
它满足一个最优子结构的一个特点

10
00:00:18,500 --> 00:00:19,300
什么是嗯

11
00:00:19,300 --> 00:00:19,933
最优子结构呢

12
00:00:19,933 --> 00:00:20,966
就是比如说

13
00:00:22,500 --> 00:00:23,033
嗯

14
00:00:23,933 --> 00:00:25,000
比如说这种呃

15
00:00:25,033 --> 00:00:25,500
比如说a b

16
00:00:26,633 --> 00:00:28,866
那它的那个指串肯定也是一个回纹串

17
00:00:28,866 --> 00:00:29,600
就比如说去掉手

18
00:00:31,666 --> 00:00:32,200
所以说

19
00:00:33,433 --> 00:00:35,000
我们就可以不用便利

20
00:00:35,000 --> 00:00:35,533
呃

21
00:00:36,333 --> 00:00:38,400
就是不用每次都要把这个b给算出来

22
00:00:39,400 --> 00:00:40,200
呃用动态规划的话

23
00:00:40,233 --> 00:00:41,166
只用算一次就可以

24
00:00:41,333 --> 00:00:41,933
呃

25
00:00:42,200 --> 00:00:44,600
然后根据这个的结果去推导出这个ABA

26
00:00:45,133 --> 00:00:46,866
就是如果说b是回纹串的话

27
00:00:47,266 --> 00:00:48,533
然后他他的ABA呢

28
00:00:50,366 --> 00:00:51,400
然后b又是回纹串

29
00:00:51,400 --> 00:00:52,666
所以说ABA肯定也是回纹串

30
00:00:52,666 --> 00:00:53,933
就是这样的一个判断方式

31
00:00:55,533 --> 00:00:57,000
它的一个那个方程就相当于是

32
00:00:57,000 --> 00:00:57,866
比如说嗯

33
00:00:57,866 --> 00:00:59,800
用动态规划维持一个

34
00:01:00,100 --> 00:01:00,633
呃

35
00:01:01,800 --> 00:01:02,666
二元的数组

36
00:01:02,666 --> 00:01:04,333
我这我这边用代码给你们讲解一下

37
00:01:04,333 --> 00:01:04,866
就是

38
00:01:05,933 --> 00:01:06,200
首先呢

39
00:01:06,233 --> 00:01:08,100
这个lead code提供了一个string函数

40
00:01:08,100 --> 00:01:08,866
然后它返回呃

41
00:01:08,900 --> 00:01:11,033
它的输入是一个主创

42
00:01:11,166 --> 00:01:11,933
主创string

43
00:01:12,333 --> 00:01:14,133
然后我们先算出它的一个长度来

44
00:01:14,133 --> 00:01:15,700
然后先减掉一些值

45
00:01:15,866 --> 00:01:18,233
这个减值就是说长度如果小于2的话

46
00:01:18,533 --> 00:01:19,133
直接就返回

47
00:01:19,133 --> 00:01:20,200
s嘛就不用算了

48
00:01:20,866 --> 00:01:23,600
然后再设一个动态的二元素组

49
00:01:23,800 --> 00:01:24,566
用Vector设

50
00:01:24,900 --> 00:01:26,366
然后二元素组的话

51
00:01:26,366 --> 00:01:27,800
就是Vector里面还有一个Vector

52
00:01:27,966 --> 00:01:28,700
然后p然

53
00:01:28,733 --> 00:01:29,666
后它这个长度是0

54
00:01:29,800 --> 00:01:31,800
然后它的那个一元的长

55
00:01:31,800 --> 00:01:32,833
一元数组的长度也是0

56
00:01:32,866 --> 00:01:34,133
然后初值都设为0

57
00:01:34,766 --> 00:01:36,900
就这样的一行就可以设置好

58
00:01:37,933 --> 00:01:39,666
然后我们呃设置两个变量

59
00:01:39,666 --> 00:01:42,333
一个是呃回文串的最长长度

60
00:01:42,366 --> 00:01:44,500
然后第二个就是最长长度回文串的对

61
00:01:44,733 --> 00:01:46,733
对这个呃字符串s的一个偏移

62
00:01:47,000 --> 00:01:49,900
然后首先我们先因为这个二元素组

63
00:01:49,933 --> 00:01:51,800
它那个它代表的意思是什么

64
00:01:51,800 --> 00:01:52,866
意思就是呃

65
00:01:53,833 --> 00:01:55,366
就是DI各字符串里面

66
00:01:57,266 --> 00:01:59,633
DI个字母是不是回纹串

67
00:02:00,633 --> 00:02:01,300
所以说在这里的话

68
00:02:01,300 --> 00:02:04,100
我们要把那种呃他对自身的那种回纹

69
00:02:04,233 --> 00:02:05,900
呃回纹串的一个判定都设为一

70
00:02:06,233 --> 00:02:08,100
这样才有这个最基本的一个呃

71
00:02:08,100 --> 00:02:08,833
判定的条件

72
00:02:09,033 --> 00:02:09,566
因为到后面的话

73
00:02:09,566 --> 00:02:11,300
我们用这种转换方程

74
00:02:11,333 --> 00:02:12,866
比如说嗯DPIJ

75
00:02:12,900 --> 00:02:14,766
就是说从DI个字母到DJ个字母

76
00:02:14,766 --> 00:02:15,300
是不是回文串

77
00:02:15,300 --> 00:02:16,600
就要需要判断它的

78
00:02:17,000 --> 00:02:18,166
它的指串是不是尾纹串

79
00:02:18,266 --> 00:02:20,233
然后并且它的呃

80
00:02:20,400 --> 00:02:20,933
第一个字母

81
00:02:20,933 --> 00:02:22,233
和最后一个字母是不是相等

82
00:02:22,766 --> 00:02:24,233
他的指串就是说i加一嘛

83
00:02:24,733 --> 00:02:26,600
i加一的字母和z减一的字母

84
00:02:26,600 --> 00:02:27,266
是不是回纹串

85
00:02:27,300 --> 00:02:27,966
如果是的话

86
00:02:28,000 --> 00:02:29,400
然后他的首尾是不是相等

87
00:02:29,533 --> 00:02:30,466
首尾的字母相等的话

88
00:02:30,466 --> 00:02:32,066
他那他这个i j就是一个回纹串

89
00:02:32,233 --> 00:02:33,133
就大概是这样的意思

90
00:02:33,833 --> 00:02:34,466
然后这边来了

91
00:02:34,466 --> 00:02:36,800
这个最重要的一个二重循环就来了

92
00:02:36,866 --> 00:02:38,466
为什么这边不能用那种呃

93
00:02:39,033 --> 00:02:40,366
哈西哈西表的方式

94
00:02:40,366 --> 00:02:41,433
去把这个二重循环

95
00:02:41,866 --> 00:02:44,600
呃外外外层的循环给呃分开掉呢

96
00:02:44,600 --> 00:02:48,833
因为它这个是为这个二元素组负值的

97
00:02:49,600 --> 00:02:50,000
它也不是

98
00:02:50,000 --> 00:02:50,733
找找

99
00:02:50,733 --> 00:02:54,600
那个值它是一个负值的一个呃功能

100
00:02:54,600 --> 00:02:55,800
所以说它不能用哈系表

101
00:02:55,800 --> 00:02:58,166
去优化掉这一个时间复杂度

102
00:02:58,466 --> 00:02:59,366
所以说这个算法

103
00:03:00,733 --> 00:03:01,800
只能是o n的平方

104
00:03:01,866 --> 00:03:02,466
然后其次呢

105
00:03:02,466 --> 00:03:03,133
为什么说

106
00:03:04,100 --> 00:03:06,466
不能用那个常规的那种呃

107
00:03:06,866 --> 00:03:08,533
II在外层的一个循环

108
00:03:09,300 --> 00:03:10,333
然后再便利这个二元素组呢

109
00:03:10,333 --> 00:03:13,500
因为我们想要便利的方式是呃

110
00:03:13,733 --> 00:03:14,400
动态规划

111
00:03:14,466 --> 00:03:16,300
我们是要从从小

112
00:03:16,366 --> 00:03:18,566
就是从小的小的那个串

113
00:03:18,600 --> 00:03:19,900
然后变利到大的那个串

114
00:03:20,500 --> 00:03:21,533
就从小串变利到大串

115
00:03:21,533 --> 00:03:22,333
并且是啊

116
00:03:22,333 --> 00:03:23,500
比如说按照长度来变的

117
00:03:26,066 --> 00:03:27,333
然后再变利长度为3的

118
00:03:27,800 --> 00:03:30,033
把那些小串是否为回纹

119
00:03:30,066 --> 00:03:31,066
回纹判断出来

120
00:03:31,866 --> 00:03:33,866
那些比那个小串长一点的

121
00:03:33,866 --> 00:03:35,300
那个大串的是否为回纹串

122
00:03:35,800 --> 00:03:36,866
所以说在这种情况下

123
00:03:37,833 --> 00:03:40,300
我们的外循环必须是考虑到为链

124
00:03:41,333 --> 00:03:41,866
就是l

125
00:03:41,966 --> 00:03:44,700
假设这个外循环就是以长度为判断的

126
00:03:45,166 --> 00:03:47,433
然后我们我们对那个

127
00:03:48,533 --> 00:03:51,800
每一啊每就相当于是便利每一列

128
00:03:51,966 --> 00:03:52,466
这

129
00:03:52,466 --> 00:03:54,133
这个二重循环的方式就是便利每一列

130
00:03:56,333 --> 00:03:57,766
长度为就是第0列

131
00:03:57,833 --> 00:03:59,033
第0列长度为2

132
00:03:59,333 --> 00:03:59,533
就比如说

133
00:03:59,533 --> 00:04:00,800
一开始第0列长度为2的

134
00:04:00,800 --> 00:04:03,266
所有的所有的那种情况

135
00:04:03,333 --> 00:04:04,366
然后再下一个就是

136
00:04:04,466 --> 00:04:05,533
然后这个i加加了

137
00:04:05,566 --> 00:04:06,500
然后就是便利第一列

138
00:04:06,500 --> 00:04:08,566
长度为2的所有的情况这样子

139
00:04:10,233 --> 00:04:11,166
然后这个z呢就是

140
00:04:11,300 --> 00:04:11,833
嗯

141
00:04:12,266 --> 00:04:13,133
这个z就是呃

142
00:04:13,133 --> 00:04:13,933
上面说到了p i z

143
00:04:13,966 --> 00:04:14,733
就是啊

144
00:04:14,733 --> 00:04:17,100
d i个字母到d z一个字母的组成的串

145
00:04:17,133 --> 00:04:18,133
是不是一个回文串

146
00:04:18,600 --> 00:04:18,966
如果说这

147
00:04:20,800 --> 00:04:23,866
那就说明这个已经呃越界了嘛

148
00:04:23,866 --> 00:04:24,933
所以说直接就break

149
00:04:25,033 --> 00:04:27,100
然后就然后就判断他们

150
00:04:29,033 --> 00:04:30,066
因为这个判断是最简单的

151
00:04:30,066 --> 00:04:31,466
所以说不相等的话直接false

152
00:04:31,933 --> 00:04:33,133
然后另一个条件就是说

153
00:04:34,500 --> 00:04:36,833
这个effect就对应着上面的这个呃

154
00:04:38,233 --> 00:04:38,766
这个and

155
00:04:39,433 --> 00:04:41,533
然后l就是嗯如果说

156
00:04:43,166 --> 00:04:43,433
如果说

157
00:04:43,433 --> 00:04:45,433
这个字符串的长度小于等于2的话

158
00:04:45,933 --> 00:04:46,666
就是小于3嘛

159
00:04:47,133 --> 00:04:48,266
那如呃

160
00:04:48,633 --> 00:04:51,033
并且他这个l情况就说SI等于s

161
00:04:51,033 --> 00:04:52,233
j SI等于SJ的话

162
00:04:52,233 --> 00:04:53,033
那他就直接等

163
00:04:53,133 --> 00:04:54,600
那他就直接是回文串了嘛

164
00:04:54,866 --> 00:04:55,633
那如果说不

165
00:04:55,666 --> 00:04:57,133
如果说他不是小于3就是j减i

166
00:04:57,166 --> 00:04:58,200
不小于3就是j减i

167
00:04:58,333 --> 00:04:59,066
呃大于3的话

168
00:04:59,066 --> 00:04:59,966
那就需要判断

169
00:05:01,033 --> 00:05:01,933
那就需要呃

170
00:05:01,966 --> 00:05:02,600
在这种情况下

171
00:05:02,600 --> 00:05:03,333
SI等于SZ

172
00:05:03,833 --> 00:05:04,900
它已经满足这个条件了

173
00:05:04,900 --> 00:05:06,233
但是它还需要满足

174
00:05:06,233 --> 00:05:07,300
它还需要这个等于一嘛

175
00:05:07,433 --> 00:05:09,166
所以说它就直接把这个值负

176
00:05:09,266 --> 00:05:10,300
把这个i加1Z减一

177
00:05:12,066 --> 00:05:13,000
是否为回文串的一个值

178
00:05:13,033 --> 00:05:15,533
复制给这个嗯复串

179
00:05:16,000 --> 00:05:17,400
然后这样就可以判断出来

180
00:05:17,466 --> 00:05:18,000
这样就可以

181
00:05:19,200 --> 00:05:20,200
把所有的p i

182
00:05:20,200 --> 00:05:21,066
j的情况都变例出来

183
00:05:21,833 --> 00:05:23,666
我们只需要就是说呃

184
00:05:23,666 --> 00:05:24,400
选出里面

185
00:05:24,866 --> 00:05:25,800
选出里面就是

186
00:05:27,000 --> 00:05:29,633
呃最长的就是z减i加一

187
00:05:30,066 --> 00:05:32,200
z减i加一就是它的长度嘛

188
00:05:32,633 --> 00:05:35,166
然后最长并且是满足这个PPI

189
00:05:35,166 --> 00:05:36,066
这等于一的情况

190
00:05:36,500 --> 00:05:37,133
如果满足的话

191
00:05:37,133 --> 00:05:39,466
那就是算出它的最长的长度

192
00:05:39,566 --> 00:05:40,466
最长回纹串的长度

193
00:05:40,466 --> 00:05:41,533
并且算出它的偏移

194
00:05:41,866 --> 00:05:43,400
然后我们再用这个呃

195
00:05:43,533 --> 00:05:45,733
string函数的substring这个功能

196
00:05:47,433 --> 00:05:49,000
把这个字符上给裁剪出来

197
00:05:49,166 --> 00:05:50,600
然后就可以实现了

198
00:05:50,733 --> 00:05:51,266
但是这样呢

199
00:05:51,266 --> 00:05:51,666
这样实现

200
00:05:51,666 --> 00:05:52,600
其实说实话

201
00:05:52,900 --> 00:05:53,433
呃

202
00:05:54,600 --> 00:05:55,133
说实话他的

203
00:00:16,666 --> 00:00:18,366
所以说它可以用动态规划来做

204
00:00:25,466 --> 00:00:26,466
a是回纹串

205
00:00:29,566 --> 00:00:31,633
去掉尾它这个b肯定也是一个回纹串

206
00:00:38,366 --> 00:00:39,133
只用算一次

207
00:00:48,500 --> 00:00:50,200
就是如果说他的首跟尾是相等的话

208
00:01:55,333 --> 00:01:56,233
D i个字母到

209
00:01:59,600 --> 00:02:00,533
是回纹串就是一

210
00:02:48,800 --> 00:02:49,600
它不是取值

211
00:02:59,333 --> 00:03:00,733
就是这个动态规划的算法

212
00:03:08,500 --> 00:03:09,266
j在里层的一个循环

213
00:03:23,466 --> 00:03:25,933
我们先要变利长度为2的

214
00:03:31,033 --> 00:03:31,833
我们才能判断去

215
00:03:54,100 --> 00:03:55,300
比如说这是呃

216
00:04:18,933 --> 00:04:20,333
个z是大于这个line的话

217
00:04:27,066 --> 00:04:28,733
首先就判断他最外层是不是相等

218
00:04:36,800 --> 00:04:37,933
这个状态方程的一个and

219
00:05:10,266 --> 00:05:12,066
就只串的一个嗯

220
00:05:21,033 --> 00:05:21,800
变例出来之后

221
00:05:45,700 --> 00:05:47,400
去把它用偏移和长度

