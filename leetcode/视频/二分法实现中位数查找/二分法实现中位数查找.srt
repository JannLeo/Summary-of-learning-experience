1
00:00:03,400 --> 00:00:04,466
又做完一题了

2
00:00:04,466 --> 00:00:06,300
兄弟们啊

3
00:00:06,300 --> 00:00:09,900
我是Leo然后今天的话是第四题

4
00:00:09,900 --> 00:00:12,266
还是在死磕这个第四题

5
00:00:12,266 --> 00:00:15,533
然后今天我来给大家说一下

6
00:00:15,533 --> 00:00:17,966
就是那个嗯

7
00:00:18,066 --> 00:00:19,466
它的一个正确的解法

8
00:00:19,466 --> 00:00:21,366
就是说最正统的一个解法

9
00:00:21,366 --> 00:00:22,500
就是呃

10
00:00:22,533 --> 00:00:26,533
时间复杂度为o log m加n的一个解法

11
00:00:26,533 --> 00:00:28,266
呃就是跟TJ里说的一样

12
00:00:28,266 --> 00:00:29,600
是用的一个

13
00:00:29,800 --> 00:00:30,600
嗯

14
00:00:30,966 --> 00:00:32,266
二分法来做的

15
00:00:32,266 --> 00:00:35,133
就是DK大的竖的那个呃

16
00:00:35,133 --> 00:00:36,700
我给大家简单讲一下

17
00:00:36,700 --> 00:00:37,933
就是那个原理吧

18
00:00:37,933 --> 00:00:40,766
就是呃之前有讲过然后

19
00:00:42,300 --> 00:00:44,966
这个寻找两个正序数组中位数

20
00:00:44,966 --> 00:00:46,866
它的条件就是说呃

21
00:00:46,866 --> 00:00:47,866
正序数组

22
00:00:48,166 --> 00:00:49,466
然后从小到大

23
00:00:49,900 --> 00:00:51,966
然后m和n个

24
00:00:52,600 --> 00:00:56,200
然后number S1和number S2找它中位数

25
00:00:57,066 --> 00:00:58,366
他的一些呃

26
00:00:58,533 --> 00:01:00,733
限制条件啊

27
00:01:00,733 --> 00:01:03,366
这些都暂时不是很重要

28
00:01:03,366 --> 00:01:06,300
我们先看这个呃

29
00:01:06,300 --> 00:01:07,500
他的一个体解

30
00:01:07,500 --> 00:01:12,000
我简单就说一下他的这个思路吧

31
00:01:17,066 --> 00:01:19,533
嗯首先二分查找嗯

32
00:01:19,966 --> 00:01:21,000
他的实践复杂度

33
00:01:21,000 --> 00:01:23,166
因为是涉及到了嗯

34
00:01:23,166 --> 00:01:27,600
二分法所以就是log log级别的然后

35
00:01:29,566 --> 00:01:30,733
然后他就是呃

36
00:01:30,733 --> 00:01:32,266
根据中位数的定义

37
00:01:32,266 --> 00:01:34,533
然后当m加n是奇数的时候

38
00:01:34,733 --> 00:01:35,800
然后就是中位数

39
00:01:35,800 --> 00:01:36,866
就是呃

40
00:01:37,566 --> 00:01:38,933
中间的那个数嘛

41
00:01:39,366 --> 00:01:41,766
就是二分之m加n的数这个数

42
00:01:41,933 --> 00:01:43,300
然后是偶数的时候

43
00:01:43,300 --> 00:01:46,333
就是二分之m加n和二分之m加n加一

44
00:01:46,333 --> 00:01:48,166
这个数去平均

45
00:01:48,733 --> 00:01:49,933
所以说这个时候

46
00:01:50,566 --> 00:01:51,533
然后就是

47
00:01:53,333 --> 00:01:55,666
他这个转换就是非常的一个巧妙

48
00:01:55,666 --> 00:01:58,366
因为他如果说DK小的一个数

49
00:01:58,366 --> 00:02:00,300
然后就是嗯

50
00:02:00,500 --> 00:02:00,666
k

51
00:02:00,666 --> 00:02:04,066
就是二分之m加n和二分之m加n加一

52
00:02:04,366 --> 00:02:05,733
然后这个k呢

53
00:02:06,466 --> 00:02:07,666
嗯我们可以

54
00:02:07,666 --> 00:02:09,900
通过这个方法来简化

55
00:02:09,900 --> 00:02:12,666
就是呃排序这个过程

56
00:02:12,666 --> 00:02:13,766
它可以把它简化成

57
00:02:13,766 --> 00:02:17,266
就说2分的k减一和b 2分的k减一

58
00:02:17,300 --> 00:02:18,533
它们这两个

59
00:02:18,666 --> 00:02:21,700
然后就是嗯来比较

60
00:02:21,700 --> 00:02:23,100
如果说a a

61
00:02:24,933 --> 00:02:28,133
比那个a比这个b小

62
00:02:28,133 --> 00:02:30,100
就是这个二分之k减一

63
00:02:30,100 --> 00:02:31,700
a的二分之k减一的值

64
00:02:31,700 --> 00:02:34,500
比b的二分之k减一的值小的话

65
00:02:34,700 --> 00:02:38,066
那就说明a前面的那些值肯定

66
00:02:40,200 --> 00:02:43,500
是在b的二分之k减一这个值的

67
00:02:44,766 --> 00:02:44,966
是

68
00:02:44,966 --> 00:02:46,533
是a前面那些值

69
00:02:46,533 --> 00:02:48,800
肯定是小于这个b的二分之k减1

70
00:02:49,266 --> 00:02:50,266
那就意味着什么呢

71
00:02:50,266 --> 00:02:53,200
就说a前这个a的二分子k减一

72
00:02:53,200 --> 00:02:54,700
前面的这些值

73
00:02:54,933 --> 00:02:56,466
它绝对绝对

74
00:02:58,266 --> 00:03:00,100
不会到k

75
00:03:00,300 --> 00:03:01,900
它不可能是d k小的数

76
00:03:01,900 --> 00:03:05,666
因为因为它们两个加起来

77
00:03:07,966 --> 00:03:11,300
他们两他们两个数数组的所有元素

78
00:03:11,300 --> 00:03:13,800
就是二分之k减一之前的那些元素

79
00:03:13,800 --> 00:03:14,533
加二分之

80
00:03:14,533 --> 00:03:16,566
这个二分之k减一之前的元素

81
00:03:16,666 --> 00:03:20,000
全部加起来才等于k减2

82
00:03:20,000 --> 00:03:22,500
对不对加上他们两个才等于k

83
00:03:23,400 --> 00:03:24,900
所以说如果说呃

84
00:03:25,133 --> 00:03:27,600
如果说这个a数组的前面这些元素

85
00:03:27,600 --> 00:03:29,933
都小于这个b数组的这个元素的话

86
00:03:30,133 --> 00:03:32,266
那他绝对不是DK小的数

87
00:03:32,466 --> 00:03:35,966
就是这样的一个意思然后嗯

88
00:03:38,166 --> 00:03:40,666
然后此时就要考虑一些特殊情况

89
00:03:40,766 --> 00:03:42,100
呃我们

90
00:03:42,100 --> 00:03:45,100
我们我们进到代码里来详细的说吧

91
00:03:45,733 --> 00:03:46,533
嗯

92
00:03:47,333 --> 00:03:48,566
大概就是那样的一个思路

93
00:03:48,566 --> 00:03:51,333
然后我们就可以继续开始呃写

94
00:03:52,100 --> 00:03:54,400
首先呢就是呃主函数

95
00:03:54,666 --> 00:03:55,466
呃

96
00:03:56,133 --> 00:04:00,900
就是找找那个中间的一个中位数

97
00:04:01,000 --> 00:04:04,666
首先定义一个他的呃总

98
00:04:04,666 --> 00:04:06,666
长度总长度就是n

99
00:04:07,700 --> 00:04:10,333
然后偏移量一二

100
00:04:10,333 --> 00:04:11,400
就对应的

101
00:04:11,733 --> 00:04:15,366
numbers一和numbers 2的一个偏移量然后

102
00:04:17,766 --> 00:04:19,766
然后这个当它偶数的时候

103
00:04:20,333 --> 00:04:22,566
我又设了一个方程

104
00:04:22,566 --> 00:04:23,100
这呃

105
00:04:23,100 --> 00:04:26,400
这个函数是用来递归的啊

106
00:04:26,400 --> 00:04:28,900
这个这个函数就是嗯

107
00:04:31,700 --> 00:04:34,333
的作用就是找第几位的一个函数

108
00:04:34,333 --> 00:04:34,800
这个

109
00:04:34,800 --> 00:04:37,500
这个二分之n就代表是第二分之n位

110
00:04:38,133 --> 00:04:39,933
然后number S1

111
00:04:40,000 --> 00:04:42,266
然后它的偏移量还有number S2

112
00:04:42,266 --> 00:04:44,333
然后它的再再一个偏移量

113
00:04:44,466 --> 00:04:46,066
为什么要加它的偏移量

114
00:04:46,266 --> 00:04:47,966
因为嗯

115
00:04:48,000 --> 00:04:49,400
以二分法的话

116
00:04:49,566 --> 00:04:51,733
也是要一点一点往下分的

117
00:04:51,733 --> 00:04:54,400
那你得必须得考虑到它的一个偏移量

118
00:04:54,566 --> 00:04:56,466
然后你再把这个数组传进去

119
00:04:56,533 --> 00:04:59,900
然后再把一个目标的目标的一个

120
00:05:00,066 --> 00:05:03,066
目标的一个第第第极小的一个数b

121
00:05:03,166 --> 00:05:05,000
比如说第二负责n

122
00:05:05,800 --> 00:05:08,666
第二分之n小的是一个数的一个目标

123
00:05:08,700 --> 00:05:11,100
传进去所以叫5个参数

124
00:05:11,300 --> 00:05:12,200
然后就是

125
00:05:14,066 --> 00:05:15,733
为什么为什么要取这两个

126
00:05:15,733 --> 00:05:17,200
因为它是偶数的时候

127
00:05:17,266 --> 00:05:20,133
分别要取左边第二分之n小的数

128
00:05:20,133 --> 00:05:23,766
还有右边第二分之n加一小的一个数

129
00:05:23,900 --> 00:05:26,700
然后他们两个再加起来除以2.0

130
00:05:27,200 --> 00:05:28,800
为什么是2.0呢因为

131
00:05:29,100 --> 00:05:29,900
呃

132
00:05:31,266 --> 00:05:33,133
这个函数我返回的是int

133
00:05:33,400 --> 00:05:35,800
所以它这里要出一个2.0啊

134
00:05:35,800 --> 00:05:37,533
这个是嗯

135
00:05:37,533 --> 00:05:38,933
一个小知识点啊

136
00:05:38,966 --> 00:05:41,133
他返回的话就会返回double

137
00:05:41,733 --> 00:05:44,100
然后我这里也强制转换了一个double

138
00:05:44,933 --> 00:05:47,700
然后l的话就是当他为基数的时候

139
00:05:47,700 --> 00:05:52,166
就是直接就取它DF帧加一的这个数

140
00:05:52,166 --> 00:05:53,066
就完事了

141
00:05:54,400 --> 00:05:55,966
然后我们看一下这个取数

142
00:05:55,966 --> 00:05:57,333
这个函数怎么写

143
00:05:57,800 --> 00:05:59,866
嗯上面这个就不用说了

144
00:06:00,000 --> 00:06:01,300
然后你要注意一点

145
00:06:01,300 --> 00:06:02,100
这个是at

146
00:06:02,100 --> 00:06:04,866
取地址符就是嗯

147
00:06:04,866 --> 00:06:07,900
防止这个就是让这个宿主返回

148
00:06:08,266 --> 00:06:10,733
返返回回去的时候就是在这

149
00:06:10,733 --> 00:06:12,566
这在这个小函数里面

150
00:06:12,566 --> 00:06:13,900
对宿主的操作

151
00:06:14,366 --> 00:06:15,166
呃

152
00:06:16,266 --> 00:06:17,733
是只是一个引用的操作

153
00:06:17,733 --> 00:06:20,766
不是说就是呃那个啥的

154
00:06:21,533 --> 00:06:25,166
然后第一个衣服就是

155
00:06:26,566 --> 00:06:27,400
判断是什么

156
00:06:27,400 --> 00:06:32,466
就是呃a数组的大小减去偏移量

157
00:06:32,466 --> 00:06:34,333
如果说大于b数组的大小

158
00:06:34,333 --> 00:06:36,300
减去b数组的偏移量的话

159
00:06:36,400 --> 00:06:36,900
说明什么

160
00:06:36,900 --> 00:06:40,500
就说明a数组的长度

161
00:06:41,300 --> 00:06:43,733
就是当前就减去偏移量的长度

162
00:06:43,733 --> 00:06:45,933
比b数组减去偏移量长度长

163
00:06:46,166 --> 00:06:48,800
那我们那么我们就要把它调换过来

164
00:06:49,266 --> 00:06:49,933
为什么调换过来

165
00:06:49,933 --> 00:06:51,566
因为我们后面考虑的时候

166
00:06:51,566 --> 00:06:53,200
都是优先考虑

167
00:06:53,700 --> 00:06:57,700
都是呃假设是a数组长度比较短的

168
00:06:58,100 --> 00:07:00,533
因为如果说你要考虑一些边界的情况

169
00:07:00,533 --> 00:07:02,066
比如说呃

170
00:07:02,066 --> 00:07:05,100
有一个数组他长度为0啊

171
00:07:05,133 --> 00:07:08,533
那肯定是a数组先考虑为0嘛

172
00:07:08,533 --> 00:07:11,000
或者说数组有越界的情况

173
00:07:11,266 --> 00:07:14,100
那就先考虑数a数组是越界情况

174
00:07:14,366 --> 00:07:15,733
然后就不用考虑b数组

175
00:07:15,733 --> 00:07:19,266
这样就可以减少一个呃代码量

176
00:07:20,800 --> 00:07:23,533
然后这个就是呃判断的一个

177
00:07:23,533 --> 00:07:28,000
如果说a数组它长度为0呢

178
00:07:28,600 --> 00:07:33,866
那我们就直接返回b数组的d k d k个数

179
00:07:34,400 --> 00:07:36,666
d k个数就是k减一下标嘛

180
00:07:37,600 --> 00:07:38,766
就是这个意思

181
00:07:39,000 --> 00:07:41,933
然后这是一个其中停下来的点

182
00:07:41,933 --> 00:07:43,866
然后另一个啊停下来减

183
00:07:43,866 --> 00:07:45,600
就是当k等于一的时候

184
00:07:46,100 --> 00:07:46,933
k k什么k

185
00:07:46,933 --> 00:07:47,800
就是这个

186
00:07:48,133 --> 00:07:49,666
这个k等于一的意思

187
00:07:49,666 --> 00:07:51,266
就是要取D1

188
00:07:52,366 --> 00:07:53,800
呃第一小的数嘛

189
00:07:54,500 --> 00:07:55,600
那就是return

190
00:07:55,700 --> 00:08:01,100
这个他们两个偏移量的一个最小值

191
00:08:01,500 --> 00:08:01,866
那为什么

192
00:08:01,866 --> 00:08:04,266
是OFFSET1和OFFSET2呢

193
00:08:04,600 --> 00:08:07,300
因为就是我们在二分法的时候

194
00:08:07,300 --> 00:08:08,200
就是这个东西

195
00:08:08,200 --> 00:08:10,133
就代表着呃

196
00:08:10,700 --> 00:08:12,466
把前面的把这个

197
00:08:12,466 --> 00:08:14,966
把这个数组啊偏移了多少

198
00:08:14,966 --> 00:08:17,066
然后偏移之后的一个新数组

199
00:08:17,066 --> 00:08:18,166
就代表了一个

200
00:08:18,733 --> 00:08:19,200
然后这个

201
00:08:19,200 --> 00:08:20,566
所以说这个OFFSET1

202
00:08:20,566 --> 00:08:23,733
就代表了当前这个数组的第一个元素

203
00:08:26,466 --> 00:08:28,700
然后这个接下来就是算那个

204
00:08:30,166 --> 00:08:35,566
正常情况就是嗯index一就是算它的mini

205
00:08:35,766 --> 00:08:36,666
呃

206
00:08:37,400 --> 00:08:38,166
它的长度的

207
00:08:38,166 --> 00:08:38,500
这

208
00:08:38,500 --> 00:08:42,200
和那个often k加offset一的一个最小值

209
00:08:42,500 --> 00:08:43,333
为什么因为

210
00:08:43,500 --> 00:08:46,166
就因为担心那个a数组的一个数组

211
00:08:46,166 --> 00:08:47,966
越界啊

212
00:08:47,966 --> 00:08:52,066
因为因为a数组是比较短的一个数组

213
00:08:52,066 --> 00:08:55,366
所以说要越界也是他优先先越界

214
00:08:55,766 --> 00:08:58,400
因为index一和index 2在呃

215
00:08:58,400 --> 00:09:01,966
正常情况下应该是嗯相同的

216
00:09:02,533 --> 00:09:05,200
然后a又属于比较短的一个数组

217
00:09:05,200 --> 00:09:08,533
所以说就优先考虑他呃越界了

218
00:09:08,533 --> 00:09:09,133
越界的话

219
00:09:09,133 --> 00:09:14,000
就直接取他a数组的一个长度的值

220
00:09:14,000 --> 00:09:14,800
就行了

221
00:09:14,900 --> 00:09:17,866
然后b数组的话就直接去他的一个

222
00:09:19,400 --> 00:09:22,666
offset加k减去二分之k

223
00:09:22,933 --> 00:09:25,333
然后为什么要k减二分之k

224
00:09:25,333 --> 00:09:26,900
是因为呃

225
00:09:29,133 --> 00:09:31,366
它这个k减二分之k

226
00:09:31,366 --> 00:09:33,600
和单纯的二分之k还是不一样的

227
00:09:33,600 --> 00:09:38,200
如果说k是一个k是一个奇数的话

228
00:09:38,533 --> 00:09:41,000
那他们的结果就是不一样

229
00:09:41,000 --> 00:09:45,533
比如说k是33/2的结果就是一对吧

230
00:09:45,533 --> 00:09:48,500
二分之k就等于3/23/2的结果是一

231
00:09:48,600 --> 00:09:55,200
但是如果说就是3-3-3/2的话就是等于2

232
00:09:55,766 --> 00:09:59,600
所以说嗯要要用k减去二分之k

233
00:10:01,300 --> 00:10:02,466
嗯然后

234
00:10:03,933 --> 00:10:06,166
然后为什么是要用k减二分之k

235
00:10:06,166 --> 00:10:07,200
因为二分

236
00:10:07,200 --> 00:10:11,500
法每次就是要呃除去一半的数嘛

237
00:10:11,500 --> 00:10:12,600
然后我们考虑

238
00:10:12,600 --> 00:10:14,200
现在这个情况是正常情况

239
00:10:14,200 --> 00:10:16,600
所以说要减去k/2

240
00:10:18,500 --> 00:10:19,300
然后

241
00:10:20,100 --> 00:10:22,666
然后接下来就是一个判断的条件语句

242
00:10:22,666 --> 00:10:26,566
如果说你分完组织后的两个数组

243
00:10:26,933 --> 00:10:29,300
比如说a数组的一个

244
00:10:30,466 --> 00:10:32,900
index减一的一个数组呃

245
00:10:32,900 --> 00:10:34,366
index减一的一个位置

246
00:10:34,366 --> 00:10:38,533
和啊必数组的in x 2-1的一个位置

247
00:10:38,733 --> 00:10:41,666
如果说他们两个小小于他的话

248
00:10:41,966 --> 00:10:43,400
那我们就找到了

249
00:10:43,866 --> 00:10:48,366
就找到了二分法之后的一个呃位置

250
00:10:49,200 --> 00:10:51,200
就是直接就return

251
00:10:51,533 --> 00:10:53,766
如吞掉就是把那个

252
00:10:55,533 --> 00:11:00,266
把a数组前面的那个index一的那些值

253
00:11:00,266 --> 00:11:01,666
全部都去掉了

254
00:11:02,166 --> 00:11:04,466
就是我们一开始判断的那个情况

255
00:11:04,466 --> 00:11:06,600
就是说如果说

256
00:11:07,600 --> 00:11:10,333
如果说这个a数值小于b数值的话

257
00:11:10,700 --> 00:11:13,700
那就说明a数值之前的那些数

258
00:11:13,766 --> 00:11:15,666
肯定是小于b数值这个数

259
00:11:15,666 --> 00:11:17,700
所以说a数值前面的数

260
00:11:17,900 --> 00:11:20,400
肯定不可能是DK大的一个数

261
00:11:20,800 --> 00:11:23,000
所以说就把它去除掉了

262
00:11:23,000 --> 00:11:25,700
所以说这里就是填的index一

263
00:11:26,700 --> 00:11:28,700
然后这个offset 2不动

264
00:11:29,166 --> 00:11:30,200
然后这个k也要

265
00:11:30,200 --> 00:11:34,000
也要根据这个数呃进行一个变换呃

266
00:11:34,000 --> 00:11:34,866
所以说

267
00:11:36,333 --> 00:11:37,366
当这个

268
00:11:39,400 --> 00:11:40,966
我找不到鼠标了我

269
00:11:42,966 --> 00:11:44,200
gear啊找到了

270
00:11:44,866 --> 00:11:49,500
呃当这个就是index一

271
00:11:49,700 --> 00:11:51,966
然后减去这个offset一之后

272
00:11:51,966 --> 00:11:53,500
就代表着呃

273
00:11:53,500 --> 00:11:55,333
这一轮这一轮

274
00:11:55,333 --> 00:11:59,000
这个a数组去除掉了多少个数字

275
00:11:59,000 --> 00:12:02,700
所以说k减去它就代表着呃

276
00:12:02,700 --> 00:12:04,733
我们的任务量已经完成了多少嘛

277
00:12:04,733 --> 00:12:06,533
就是二分法分掉了多少

278
00:12:06,866 --> 00:12:08,266
就这样的一个意思

279
00:12:10,166 --> 00:12:10,933
然后

280
00:12:10,933 --> 00:12:17,066
如果说是是a数组大于b数组的时候

281
00:12:17,400 --> 00:12:18,766
那就是把b数

282
00:12:18,766 --> 00:12:20,666
组前面的那些数给去掉

283
00:12:21,400 --> 00:12:23,266
所以说这里就是index 2

284
00:12:24,300 --> 00:12:28,466
然后就是相应的k也要减小掉

285
00:12:28,600 --> 00:12:30,466
那个分调的那些数

286
00:12:30,966 --> 00:12:33,000
就是可以减去index 2

287
00:12:33,000 --> 00:12:34,100
减offset 2

288
00:12:34,933 --> 00:12:39,466
然后这就是一个递归的一个过程

289
00:12:40,666 --> 00:12:41,600
嗯

290
00:12:43,500 --> 00:12:45,800
也希望大家好好理解一下

291
00:12:45,800 --> 00:12:46,066
这个

292
00:12:46,066 --> 00:12:50,533
也是我从b站上某某个up主学过来的

293
00:12:50,866 --> 00:12:52,933
然后就是做了一下总结

294
00:12:53,600 --> 00:12:55,466
呃有可能下一次我遇到这种题

295
00:12:55,466 --> 00:12:56,366
我还是不会做

296
00:12:56,366 --> 00:13:00,566
因为这个地规确实有点难想想出来

297
00:13:00,566 --> 00:13:02,466
但是他这样做确实很方便

298
00:13:02,466 --> 00:13:04,666
你看才三四十行

299
00:13:05,000 --> 00:13:06,666
40行不到就做完了

300
00:13:07,100 --> 00:13:08,133
那你像我上一次的话

301
00:13:08,133 --> 00:13:08,733
我可以做到

302
00:13:08,733 --> 00:13:10,133
我要做到70多行

303
00:13:10,133 --> 00:13:12,900
我才能把它暴力破解出来

304
00:13:12,966 --> 00:13:14,500
它像这种地规的话

305
00:13:14,666 --> 00:13:17,966
它不仅是时间复杂度为log log n

306
00:13:18,133 --> 00:13:19,566
m加n的最大值

307
00:13:20,300 --> 00:13:21,800
而且还就是啊

308
00:13:21,800 --> 00:13:22,966
为什么我说一下

309
00:13:22,966 --> 00:13:23,366
为什么

310
00:13:23,366 --> 00:13:26,500
它的时间复杂度是log m加n的最大值

311
00:13:27,300 --> 00:13:28,133
呃因为

312
00:13:29,466 --> 00:13:31,133
它这里涉及到了一个

313
00:13:31,366 --> 00:13:33,100
这里涉及到一个二分法

314
00:13:34,266 --> 00:13:35,666
就是这里嘛

315
00:13:35,666 --> 00:13:37,366
这个k减二分之k

316
00:13:37,900 --> 00:13:39,900
还有这个二分之k加set一

317
00:13:40,466 --> 00:13:42,333
他这里就是用到了一个二分法

318
00:13:43,466 --> 00:13:44,966
就k k除以2嘛

319
00:13:45,200 --> 00:13:47,333
然后就说要执行的步数

320
00:13:47,333 --> 00:13:49,766
比如说正常正常步骤执行的步数

321
00:13:49,966 --> 00:13:51,333
这就是正常步骤嘛

322
00:13:51,466 --> 00:13:53,266
如果说要执行的步数

323
00:13:53,266 --> 00:13:56,366
那就是比如说k k

324
00:13:56,900 --> 00:13:59,700
从正常正常原始的一个k

325
00:13:59,766 --> 00:14:00,466
每次除以2

326
00:14:00,466 --> 00:14:02,300
除以2 一直除到等于一的时候

327
00:14:02,300 --> 00:14:03,466
它就跳出去了

328
00:14:04,533 --> 00:14:07,800
这就是一个时间复杂度

329
00:14:07,800 --> 00:14:11,000
算起来就是一个log log级别的

330
00:14:11,466 --> 00:14:11,900
懂我意思吧

331
00:14:11,900 --> 00:14:14,500
就是2为底的一个对数的一个级别

332
00:14:15,266 --> 00:14:15,733
大概就是

333
00:14:15,733 --> 00:14:16,600
这样的意思

334
00:14:17,333 --> 00:14:18,566
好这就是一个

335
00:14:20,966 --> 00:14:22,866
大概就是呃

336
00:14:22,866 --> 00:14:24,366
第四题的一个

337
00:14:26,000 --> 00:14:28,333
第四题一个2分查找的一个解法

338
00:14:28,400 --> 00:14:29,500
然后明天的话

339
00:14:29,500 --> 00:14:31,966
我会继续把这个

340
00:14:33,500 --> 00:14:34,933
最难的一个解法

341
00:14:34,933 --> 00:14:38,733
就是划分数组的解法的一个代码

342
00:14:39,733 --> 00:14:41,366
给大家讲解

343
00:14:41,366 --> 00:14:42,066
并且实现

344
00:14:42,066 --> 00:14:43,666
谢谢大家

