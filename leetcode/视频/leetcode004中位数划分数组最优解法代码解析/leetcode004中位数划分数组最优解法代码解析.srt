1
00:00:02,800 --> 00:00:03,400
又做完一题啦

2
00:00:03,400 --> 00:00:03,933
兄弟们

3
00:00:04,133 --> 00:00:06,533
今天第四题还是继续第四题呃

4
00:00:06,533 --> 00:00:08,133
不过是最快的解法

5
00:00:08,166 --> 00:00:09,666
然后第四题

6
00:00:09,666 --> 00:00:11,733
就是那个找正序数组的中位数

7
00:00:12,100 --> 00:00:13,233
然后解法呢

8
00:00:13,500 --> 00:00:16,033
就是我用了体解里面的最快的

9
00:00:17,266 --> 00:00:18,600
就是那个划分数组的解法

10
00:00:18,600 --> 00:00:21,000
然后它的时间复杂度是呃

11
00:00:22,066 --> 00:00:22,600
o

12
00:00:25,133 --> 00:00:26,400
o log m加呃

13
00:00:26,400 --> 00:00:29,366
o log m或者n的最大值的一个复

14
00:00:29,400 --> 00:00:29,933
时间复杂度

15
00:00:29,933 --> 00:00:31,533
它比那个二分法的时间复杂度

16
00:00:31,533 --> 00:00:32,366
小了一个

17
00:00:33,000 --> 00:00:34,100
嗯量级吧

18
00:00:34,100 --> 00:00:34,633
也不算量级

19
00:00:34,633 --> 00:00:35,766
就是小小了一点点

20
00:00:35,800 --> 00:00:37,000
就是会快快一点

21
00:00:38,866 --> 00:00:40,400
就是今天这个划分数组嗯

22
00:00:41,400 --> 00:00:42,133
我上期有呃

23
00:00:42,166 --> 00:00:42,633
有一期视频

24
00:00:42,633 --> 00:00:44,066
是讲到了这个划分数组的

25
00:00:44,066 --> 00:00:45,733
一个理论的一个分析

26
00:00:45,733 --> 00:00:47,500
然后今天我是用代码实现了

27
00:00:47,533 --> 00:00:48,066
然后

28
00:00:48,500 --> 00:00:50,733
今天主要就是讲代码上面的一个逻辑

29
00:00:51,400 --> 00:00:53,266
然后我们来看一下这个

30
00:00:54,866 --> 00:00:55,400
这个

31
00:00:57,766 --> 00:00:58,866
好我们先呃看一下

32
00:00:58,866 --> 00:01:01,900
就是我们从这个呃这个函数可以入手

33
00:01:01,933 --> 00:01:04,066
呃首先他给了我们两个呃

34
00:01:04,066 --> 00:01:05,533
intervector的一个数组

35
00:01:05,633 --> 00:01:07,833
然后我就是用划分数组的方法

36
00:01:07,833 --> 00:01:09,466
首先定义一个m和n

37
00:01:09,466 --> 00:01:11,466
就是代表这两个数组的一个呃

38
00:01:11,466 --> 00:01:12,000
大小

39
00:01:12,433 --> 00:01:14,433
就是有多少个元素然后

40
00:01:15,433 --> 00:01:17,366
呃因为我就是它

41
00:01:17,366 --> 00:01:20,900
这个算法的时间复杂度是o log呃m

42
00:01:21,800 --> 00:01:24,400
或者m的m或者n的一个最大值

43
00:01:24,566 --> 00:01:26,866
所以说我就假设m是最小

44
00:01:27,100 --> 00:01:27,800
m是小于n的

45
00:01:27,800 --> 00:01:28,733
就是呃

46
00:01:28,866 --> 00:01:31,666
number S1的数组是小于number S2的数组的

47
00:01:31,800 --> 00:01:32,833
所以在这个情况下

48
00:01:32,866 --> 00:01:33,733
我就用d规

49
00:01:33,933 --> 00:01:34,233
这是一个

50
00:01:34,233 --> 00:01:36,600
d规然后就是把呃让

51
00:01:36,600 --> 00:01:38,266
这就是m永远都是小于n的

52
00:01:38,333 --> 00:01:39,666
就是产生了这样的一个情况

53
00:01:40,233 --> 00:01:41,133
呃然后

54
00:01:42,800 --> 00:01:43,233
然后你们会问

55
00:01:43,266 --> 00:01:44,066
就是说呃

56
00:01:44,066 --> 00:01:45,300
m和n在这里已经求了

57
00:01:45,300 --> 00:01:46,366
为什么你在这边的话

58
00:01:46,366 --> 00:01:47,266
调用这个函数之后

59
00:01:47,300 --> 00:01:48,700
这个m和n不应该改变吗

60
00:01:48,966 --> 00:01:49,766
会其实是会改变

61
00:01:49,766 --> 00:01:52,766
就是呃就是我如果说m大于n的话

62
00:01:52,833 --> 00:01:55,066
比如说这个number S1数组有3个元素

63
00:01:55,133 --> 00:01:57,000
这个number S2的数组只有一个元素的话

64
00:01:57,266 --> 00:01:57,666
在这边的话

65
00:01:57,666 --> 00:01:58,933
他会进入到这个分支里面

66
00:01:59,100 --> 00:01:59,633
进入到这个分支

67
00:01:59,666 --> 00:02:01,133
他首先会去运行这个函数

68
00:02:01,266 --> 00:02:02,633
这个函数就是把呃

69
00:02:02,633 --> 00:02:04,800
那这里的numbers 2放到了numbers一的位置

70
00:02:04,800 --> 00:02:05,666
然后这里的numbers一

71
00:02:05,666 --> 00:02:06,800
放到了numbers 2的位置

72
00:02:06,933 --> 00:02:08,200
然后他就运行这个函数去了

73
00:02:08,333 --> 00:02:09,833
相当于把他们两个调了一个位置

74
00:02:10,200 --> 00:02:11,333
然后他返回了这个值

75
00:02:11,533 --> 00:02:13,133
然后再到就是他

76
00:02:13,133 --> 00:02:15,133
他进到这一个呃地规里面去了的

77
00:02:15,333 --> 00:02:16,933
呃函数运行完之后的一个结果呢

78
00:02:17,133 --> 00:02:17,833
他返回了出来

79
00:02:17,833 --> 00:02:19,166
然后他再执行执行这一条语句

80
00:02:19,166 --> 00:02:19,700
return

81
00:02:20,200 --> 00:02:21,933
他return这个值就return到这个double这里

82
00:02:22,066 --> 00:02:23,266
然后它就可以算出一个结果

83
00:02:24,066 --> 00:02:24,433
就这样了

84
00:02:24,433 --> 00:02:25,200
所以说这个m和n

85
00:02:25,200 --> 00:02:26,666
其实对这里面这个东西没有影响

86
00:02:27,033 --> 00:02:27,766
它这里面已经

87
00:02:27,766 --> 00:02:28,266
这个函数里面

88
00:02:28,266 --> 00:02:29,466
已经重新生成了一个m和n

89
00:02:29,933 --> 00:02:33,200
然后我们首先进行一个呃i i MI minimum

90
00:02:33,200 --> 00:02:34,666
还有i Max的一个设置

91
00:02:34,766 --> 00:02:36,933
呃这个适用于后续的一个二分法

92
00:02:36,966 --> 00:02:37,966
因为划分数组的话

93
00:02:37,966 --> 00:02:39,233
其实也是要用到二分法

94
00:02:39,233 --> 00:02:40,466
只是说呃

95
00:02:40,633 --> 00:02:43,133
我们是把它变成了一个

96
00:02:43,733 --> 00:02:44,300
只看

97
00:02:44,800 --> 00:02:45,100
只看

98
00:02:45,133 --> 00:02:47,933
那个i或m或者n最大值的一种方式

99
00:02:47,933 --> 00:02:49,033
去做的一个二分法

100
00:02:49,033 --> 00:02:50,566
就是都是log级别

101
00:02:50,566 --> 00:02:52,966
只是说他呃他跟二分法都是log级别

102
00:02:52,966 --> 00:02:54,066
只是说这个划分数组的话

103
00:02:54,066 --> 00:02:55,733
他呃在log级别里面

104
00:02:55,733 --> 00:02:57,533
他减掉了一个比较大的一个n

105
00:02:58,866 --> 00:03:01,000
然后就是当当这个最小值和最大值

106
00:03:01,333 --> 00:03:02,966
最小值小于等于最大值的时候

107
00:03:03,233 --> 00:03:05,133
然后我们就在这个循环里面进行

108
00:03:05,400 --> 00:03:06,033
一般一般来讲

109
00:03:06,033 --> 00:03:07,966
其实这个算法是跳不出这个循环的

110
00:03:08,133 --> 00:03:09,266
因为在这个循环里面就可以呃

111
00:03:09,300 --> 00:03:10,700
return出去了然后

112
00:03:11,900 --> 00:03:12,433
我们这里有个条件

113
00:03:12,466 --> 00:03:13,266
就是说呃

114
00:03:13,266 --> 00:03:13,933
i加z

115
00:03:13,966 --> 00:03:16,900
是等于这两个数组的长度除以2的

116
00:03:17,033 --> 00:03:18,600
这两个数组数组长度之和除以2

117
00:03:18,600 --> 00:03:19,133
为什么要这么做呢

118
00:03:19,133 --> 00:03:22,200
因为划分数组就是想要呃画

119
00:03:22,300 --> 00:03:22,966
找出它的中位数

120
00:03:22,966 --> 00:03:23,433
它们两个

121
00:03:23,433 --> 00:03:24,033
它们两个

122
00:03:24,066 --> 00:03:26,600
呃它们两个数组的一个总长度

123
00:03:26,966 --> 00:03:27,533
画一半

124
00:03:28,000 --> 00:03:28,733
画一半之后呢

125
00:03:29,266 --> 00:03:29,933
画一半之后

126
00:03:30,600 --> 00:03:31,133
然后算

127
00:03:31,133 --> 00:03:32,600
这两边这个数不就是中位数了吗

128
00:03:32,600 --> 00:03:34,566
所以说我们就假设呃

129
00:03:35,733 --> 00:03:37,366
i加z是等于它的一半

130
00:03:37,433 --> 00:03:37,933
总长度的一半

131
00:03:37,933 --> 00:03:39,000
就说明呃

132
00:03:39,233 --> 00:03:40,500
number S1左边的数组

133
00:03:40,533 --> 00:03:42,000
和number S2右左边的数组

134
00:03:42,033 --> 00:03:43,500
加起来是总长度的一半

135
00:03:43,666 --> 00:03:44,033
这样的话

136
00:03:44,033 --> 00:03:46,466
我们呃i和j划分出来的那个

137
00:03:46,933 --> 00:03:48,666
它的两边的一个

138
00:03:48,866 --> 00:03:49,600
左边的一个最大值

139
00:03:49,600 --> 00:03:50,666
和右边的一个最小值

140
00:03:51,266 --> 00:03:53,400
就是中位数的取值了

141
00:03:53,633 --> 00:03:54,366
就是这样的一个意思

142
00:03:54,366 --> 00:03:56,333
这就是划分数组的一个中心思想

143
00:03:56,700 --> 00:03:57,366
然后首先我们来看

144
00:03:58,100 --> 00:03:59,200
首先这是一个二分法的开始

145
00:03:59,200 --> 00:03:59,666
二分法的话

146
00:03:59,666 --> 00:04:02,400
就是i取这两个值的一个中间值嘛

147
00:04:02,433 --> 00:04:03,066
这叫二分法

148
00:04:03,233 --> 00:04:04,166
二分法的一个概念

149
00:04:04,333 --> 00:04:05,433
然后z的话

150
00:04:05,433 --> 00:04:07,766
因为z是跟i有这个条件关系的

151
00:04:08,333 --> 00:04:08,733
所以说呢

152
00:04:08,766 --> 00:04:10,300
就是z就直接等于这个

153
00:04:11,300 --> 00:04:13,400
m加n加1/2

154
00:04:13,400 --> 00:04:14,066
然后再减去i

155
00:04:14,733 --> 00:04:15,600
就是把这个i挪过去

156
00:04:16,666 --> 00:04:17,800
所以说现在的这个情况就是

157
00:04:17,800 --> 00:04:19,933
我们只用看i的一个变化情况就行了

158
00:04:20,000 --> 00:04:22,000
i增加然后呃

159
00:04:22,033 --> 00:04:22,966
那么S1就会增加

160
00:04:23,000 --> 00:04:24,200
因为它是个递增数组

161
00:04:24,233 --> 00:04:25,466
然后i增加

162
00:04:25,833 --> 00:04:26,633
z就会减小

163
00:04:26,633 --> 00:04:28,933
z减小那么S2就会减小

164
00:04:29,000 --> 00:04:30,433
所以说只用看i的一个变化

165
00:04:31,600 --> 00:04:32,533
好这个j的话

166
00:04:32,533 --> 00:04:35,933
就是应该是等于这个m加n加1/2减i

167
00:04:36,400 --> 00:04:39,666
然后我们现在要考虑呃二分法

168
00:04:39,666 --> 00:04:42,400
当i大了和小了的时候

169
00:04:43,033 --> 00:04:44,566
就是因为我们要用二分法嘛

170
00:04:44,600 --> 00:04:47,400
然后二分法的话就是要有一个呃分

171
00:04:47,400 --> 00:04:48,266
二分的一个逼近

172
00:04:48,300 --> 00:04:49,466
二分的逼近的话就要考虑到

173
00:04:49,533 --> 00:04:51,266
比如说0-100是呃

174
00:04:51,266 --> 00:04:52,533
目标数是25的时候

175
00:04:52,666 --> 00:04:53,800
那如果我取50的话

176
00:04:53,833 --> 00:04:54,633
那就是大了

177
00:04:54,700 --> 00:04:57,133
大了的话就把这个i Max变成一个50-1

178
00:04:57,133 --> 00:04:58,800
就是449对吧

179
00:04:59,000 --> 00:05:00,100
所以说现在要考虑一个情况

180
00:05:00,100 --> 00:05:01,900
就是呃大了

181
00:05:01,933 --> 00:05:03,200
i大了或者i小了的一个情况

182
00:05:03,200 --> 00:05:03,800
i大了的情况呢

183
00:05:03,833 --> 00:05:04,800
就是呃这样考虑了

184
00:05:04,800 --> 00:05:06,100
就比如说呃

185
00:05:06,233 --> 00:05:07,300
当这个呃

186
00:05:07,300 --> 00:05:08,900
假如说这个number S1数组是a

187
00:05:09,066 --> 00:05:10,100
number S2数组是b

188
00:05:11,533 --> 00:05:13,266
假如说这个i分设在这个地方

189
00:05:13,766 --> 00:05:14,466
z射在这个地方

190
00:05:14,933 --> 00:05:17,600
那如果说这个4比这个3大了

191
00:05:17,700 --> 00:05:18,033
什么意思

192
00:05:18,066 --> 00:05:19,966
就是呃这个左边的数组

193
00:05:20,133 --> 00:05:22,066
他的一个最大值

194
00:05:22,100 --> 00:05:23,966
比右边的数组的最小值要大

195
00:05:24,366 --> 00:05:25,566
说明这个划分是不正确的

196
00:05:25,566 --> 00:05:26,500
这个划分要怎么划

197
00:05:26,500 --> 00:05:28,033
就是说要把这个

198
00:05:29,066 --> 00:05:31,066
这个i这这个i往左移对吧

199
00:05:31,133 --> 00:05:32,500
往左移往左移的话

200
00:05:32,500 --> 00:05:33,900
这个a的i减一才会变小

201
00:05:35,500 --> 00:05:35,800
等于什么

202
00:05:35,800 --> 00:05:36,400
就是就是说

203
00:05:36,433 --> 00:05:36,900
比如说

204
00:05:36,900 --> 00:05:39,700
因为i跟这个这个数组是成正比的

205
00:05:39,700 --> 00:05:40,666
i大这个就大

206
00:05:41,033 --> 00:05:42,433
然后II大的话

207
00:05:42,466 --> 00:05:43,000
这个就小

208
00:05:43,033 --> 00:05:43,700
所以说呢

209
00:05:44,766 --> 00:05:46,833
所以说当当这个数组

210
00:05:46,866 --> 00:05:49,033
number S1数组大于number S2数组的时候

211
00:05:49,433 --> 00:05:50,300
我们想让它变

212
00:05:50,500 --> 00:05:53,400
变得小让它小于这个number S2数组

213
00:05:53,400 --> 00:05:55,600
那我们是不是就应该把这个i呃

214
00:05:55,600 --> 00:05:56,333
把这个i调小

215
00:05:57,866 --> 00:05:59,133
但是就在这种情况下

216
00:05:59,166 --> 00:06:01,033
我们要a数组小于b数组

217
00:06:01,100 --> 00:06:02,500
但是他a数组大于b数组了

218
00:06:02,500 --> 00:06:03,600
那是不是i就大了

219
00:06:03,800 --> 00:06:04,733
是因为就i大了

220
00:06:04,766 --> 00:06:05,166
i大了的话

221
00:06:05,166 --> 00:06:07,933
我们就要把这个i Max变成i减一

222
00:06:08,100 --> 00:06:08,866
比如说0到100

223
00:06:08,900 --> 00:06:09,800
我的目标是25

224
00:06:10,100 --> 00:06:10,966
然后我取了5十

225
00:06:11,500 --> 00:06:12,133
i是不是大了

226
00:06:12,133 --> 00:06:12,800
i大了的话

227
00:06:12,866 --> 00:06:14,200
550是不是也是大了

228
00:06:14,233 --> 00:06:16,500
就取4949 就是i Max变成49

229
00:06:16,500 --> 00:06:17,166
就是i减一

230
00:06:17,333 --> 00:06:18,366
对吧就这样的一个意思

231
00:06:19,766 --> 00:06:21,466
然后为什么我要取这种呃

232
00:06:21,466 --> 00:06:22,333
为什么我要呃

233
00:06:22,366 --> 00:06:23,300
舍掉这些条件

234
00:06:23,333 --> 00:06:25,200
因为呃当i等于0的时候

235
00:06:25,966 --> 00:06:26,800
i等于0的时候

236
00:06:27,333 --> 00:06:28,466
在i在这个这个地方

237
00:06:29,033 --> 00:06:29,700
i在这个地方

238
00:06:30,166 --> 00:06:31,433
假设i在这个地方的时候

239
00:06:31,433 --> 00:06:32,400
j在这个地方的时候

240
00:06:33,033 --> 00:06:34,100
那是不是就说明

241
00:06:34,433 --> 00:06:35,733
左边这个数组上面没有数

242
00:06:35,733 --> 00:06:37,066
上面没有数的话就不用比较

243
00:06:37,066 --> 00:06:38,866
就直接左边这边的一个最大值

244
00:06:38,900 --> 00:06:41,666
肯定是b数组这个z的旁边这个值

245
00:06:41,666 --> 00:06:42,200
对吧

246
00:06:43,533 --> 00:06:44,400
然后其次的话

247
00:06:45,033 --> 00:06:45,966
这是一个特殊情况

248
00:06:45,966 --> 00:06:47,566
然后j等于n也是一个特殊情况

249
00:06:47,633 --> 00:06:49,333
这两个特殊情况会影响到什么来

250
00:06:49,333 --> 00:06:50,666
注塑当i等于0的时候呢

251
00:06:50,766 --> 00:06:51,966
那number S1I减一

252
00:06:51,966 --> 00:06:52,633
这个取不到值

253
00:06:52,633 --> 00:06:53,933
越界了所以说

254
00:06:53,966 --> 00:06:56,300
我们要把这个特殊情况单独去考虑

255
00:06:56,500 --> 00:06:57,333
这个也是同理

256
00:06:58,200 --> 00:06:59,966
然后当在这个地方

257
00:06:59,966 --> 00:07:01,466
就是number S1的i

258
00:07:02,166 --> 00:07:03,966
小于这个number S2的j减一的时候

259
00:07:03,966 --> 00:07:04,200
什么意思

260
00:07:04,200 --> 00:07:04,866
就是说呃

261
00:07:04,866 --> 00:07:08,066
当a数组的一个呃划分的右边这个

262
00:07:08,166 --> 00:07:10,800
这个值小于了这个b数组划分左边的

263
00:07:10,800 --> 00:07:11,666
这个值的时候

264
00:07:12,600 --> 00:07:12,933
什么情况

265
00:07:12,933 --> 00:07:14,600
就是那就是我要

266
00:07:17,400 --> 00:07:18,100
我的期待是什么

267
00:07:18,100 --> 00:07:20,266
我的期待就是说呃a数组

268
00:07:21,433 --> 00:07:23,033
a数组AI的话

269
00:07:23,033 --> 00:07:24,766
它要大于BJ减一

270
00:07:24,766 --> 00:07:26,166
但是它这个时候它小了

271
00:07:26,433 --> 00:07:27,133
所以说是什么

272
00:07:27,133 --> 00:07:27,933
i小了

273
00:07:28,433 --> 00:07:28,966
对吧

274
00:07:29,333 --> 00:07:31,266
因为a是本来要大于b的

275
00:07:31,266 --> 00:07:32,333
但现在是a小于b

276
00:07:32,600 --> 00:07:33,666
所以a是不是要提高

277
00:07:34,100 --> 00:07:35,233
a提高才能a大于b

278
00:07:35,300 --> 00:07:36,666
a大于b a要提高的话呢

279
00:07:36,666 --> 00:07:37,400
就是i要提高

280
00:07:38,333 --> 00:07:38,800
i要提高

281
00:07:38,833 --> 00:07:39,666
i提高的话那就

282
00:07:41,233 --> 00:07:42,133
II小了嘛

283
00:07:42,233 --> 00:07:44,066
i小的话就改变III命

284
00:07:44,500 --> 00:07:45,500
所以说就变成i加一

285
00:07:46,500 --> 00:07:49,100
然后其余的情况就是一个呃

286
00:07:49,133 --> 00:07:51,200
要么就是上述的这种边界情况

287
00:07:51,566 --> 00:07:53,000
要么就是二分法完成之后

288
00:07:53,666 --> 00:07:54,400
二分法完成之后

289
00:07:54,400 --> 00:07:55,300
满足条件的情况

290
00:07:55,700 --> 00:07:57,000
当他为边界情况的时候

291
00:07:59,566 --> 00:08:00,266
当它为边界情况时候

292
00:08:00,266 --> 00:08:01,000
比如说i等于0

293
00:08:01,233 --> 00:08:02,000
i等于0 刚刚也说了

294
00:08:02,000 --> 00:08:03,000
就说i等于0的时候

295
00:08:03,433 --> 00:08:04,600
那这个时候呃

296
00:08:04,766 --> 00:08:06,133
左边这左边这个划分的数组

297
00:08:06,166 --> 00:08:07,833
它的最大值肯定是呃

298
00:08:08,633 --> 00:08:09,166
d j

299
00:08:09,433 --> 00:08:10,966
就是这个j的左边

300
00:08:11,933 --> 00:08:13,833
划分j划分左边的这一个值

301
00:08:14,300 --> 00:08:15,133
所以说左边的一个最大值

302
00:08:15,133 --> 00:08:16,600
就等于b数组的z减一

303
00:08:17,300 --> 00:08:18,100
然后当z等于0的时候

304
00:08:18,100 --> 00:08:19,166
就是这个地方

305
00:08:19,533 --> 00:08:20,500
它划分在它这个

306
00:08:20,500 --> 00:08:21,566
z的划分在这个地方的时候

307
00:08:21,700 --> 00:08:22,500
那左边的最大值

308
00:08:22,500 --> 00:08:24,100
是不是就等于a的i减一

309
00:08:24,500 --> 00:08:25,033
是吧

310
00:08:25,966 --> 00:08:26,633
然后其余的情况呢

311
00:08:26,633 --> 00:08:29,166
就是我们为什么要先考虑左边最大值

312
00:08:31,800 --> 00:08:33,933
因为考虑左边最大值就是当这个嗯

313
00:08:34,366 --> 00:08:34,733
当这个m

314
00:08:34,733 --> 00:08:35,833
加n为奇数的时候

315
00:08:36,633 --> 00:08:38,300
这边这个这个为奇数

316
00:08:38,500 --> 00:08:39,333
这个为奇数的话

317
00:08:39,433 --> 00:08:40,033
加一的话

318
00:08:40,033 --> 00:08:41,266
他就会比原来多一

319
00:08:41,300 --> 00:08:42,066
那如果是偶数的话

320
00:08:42,066 --> 00:08:43,133
会比原来少一的

321
00:08:44,466 --> 00:08:45,333
我们默认情况是

322
00:08:45,366 --> 00:08:46,800
把那个多出来的那一个数

323
00:08:46,900 --> 00:08:48,033
放在那个左边的一个部分

324
00:08:48,033 --> 00:08:49,566
所以说我们先求左边的一个最大值

325
00:08:49,733 --> 00:08:51,066
如果说他是奇数的时候

326
00:08:51,066 --> 00:08:52,666
我们直接就返回左边最大值就行了

327
00:08:53,400 --> 00:08:54,000
那如果是偶数的话

328
00:08:54,000 --> 00:08:54,933
我们继续往下写

329
00:08:54,966 --> 00:08:56,000
就可能要多算一点点

330
00:08:56,366 --> 00:08:56,500
这样

331
00:08:56,500 --> 00:08:58,100
就是为了减少一个时间的一个损耗

332
00:08:58,900 --> 00:08:59,166
然后

333
00:08:59,166 --> 00:09:00,766
我们在这里设置一个右边的最小值

334
00:09:01,033 --> 00:09:02,866
就是考虑先考虑一下那些特殊情况

335
00:09:02,966 --> 00:09:04,966
然后再去算出它的

336
00:09:05,600 --> 00:09:06,666
当它普通情况的时候

337
00:09:06,666 --> 00:09:07,700
就是呃

338
00:09:08,433 --> 00:09:09,433
取它的一个

339
00:09:10,266 --> 00:09:10,733
取它的一个

340
00:09:10,733 --> 00:09:11,466
右边最小值的话

341
00:09:11,466 --> 00:09:12,500
就是取呃

342
00:09:12,500 --> 00:09:14,400
numbers 2的z或者numbers一的i嘛

343
00:09:14,633 --> 00:09:15,866
这里为什么不是i加一和z加一

344
00:09:15,866 --> 00:09:18,100
是因为我一开始写的时候也写错了

345
00:09:18,166 --> 00:09:19,433
这里不是i加一和z加一的原因

346
00:09:19,433 --> 00:09:22,800
就是它的一个数组是从0开始算的

347
00:09:23,133 --> 00:09:24,400
所以说呃

348
00:09:25,333 --> 00:09:26,500
所以说你取到那个

349
00:09:27,433 --> 00:09:29,233
你取到你取j在这个地方的时候

350
00:09:30,033 --> 00:09:31,233
你比如说取j等于0

351
00:09:32,033 --> 00:09:32,766
j等于0的话

352
00:09:35,066 --> 00:09:37,966
他右边这个数是是b 0来的对吧

353
00:09:37,966 --> 00:09:38,766
他右边这个数是b 0

354
00:09:38,800 --> 00:09:39,933
他不是b 0加一

355
00:09:40,633 --> 00:09:42,266
所以说就是他是从0开始算

356
00:09:42,266 --> 00:09:43,466
所以说这边不用加1

357
00:09:43,733 --> 00:09:44,466
然后当偶数的时候

358
00:09:44,466 --> 00:09:46,933
就是把左边最大值和右边最小值

359
00:09:46,966 --> 00:09:48,333
除以2 返回去就行了

360
00:09:48,333 --> 00:09:49,000
这里为什么是2.0

361
00:09:49,033 --> 00:09:50,100
因为返回的是呃

362
00:09:50,100 --> 00:09:51,033
他这个是一个double

363
00:09:51,233 --> 00:09:52,166
然后偶数的时候要返回一

364
00:09:52,166 --> 00:09:53,300
个呃double值

365
00:09:53,333 --> 00:09:54,900
所以说上面这两个是int

366
00:09:54,900 --> 00:09:57,033
所以说就这里要写个2.0 啊

367
00:09:57,066 --> 00:09:57,666
大概就是这样

