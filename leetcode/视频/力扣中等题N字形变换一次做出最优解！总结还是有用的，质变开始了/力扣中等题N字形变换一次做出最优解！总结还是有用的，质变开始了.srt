1
00:00:03,033 --> 00:00:03,566
呃大家好

2
00:00:03,600 --> 00:00:06,433
我是Leo然后今天继续来讲一下

3
00:00:06,466 --> 00:00:07,300
呃第6题

4
00:00:07,533 --> 00:00:08,266
n字形变换

5
00:00:08,266 --> 00:00:09,933
然后它是一个中等题啊

6
00:00:10,200 --> 00:00:12,033
然后今天是我第一次呃

7
00:00:12,366 --> 00:00:14,400
就是只用了不到一个小时的时间

8
00:00:14,433 --> 00:00:15,100
把这个做出来

9
00:00:15,100 --> 00:00:15,800
而且是

10
00:00:16,033 --> 00:00:19,033
而且他的这个记录是一个非常完美的

11
00:00:19,033 --> 00:00:21,266
我击败了91的C++用户

12
00:00:21,266 --> 00:00:23,900
用时然后内存是击败了89%的用户

13
00:00:24,000 --> 00:00:26,166
我觉得已经是非常完美的一个解法了

14
00:00:26,433 --> 00:00:27,500
然后我现在分享给大家

15
00:00:27,600 --> 00:00:28,566
首先就是n字形变化

16
00:00:28,566 --> 00:00:29,166
我读一下题目

17
00:00:29,200 --> 00:00:31,100
就是给定一个字符串s

18
00:00:31,200 --> 00:00:32,766
根据给定的函数numbers

19
00:00:32,800 --> 00:00:33,700
然后从上往下

20
00:00:33,733 --> 00:00:35,433
从左往右进行z字形排列

21
00:00:37,266 --> 00:00:38,600
看到这里是不是很迷惑

22
00:00:38,866 --> 00:00:41,033
呃比如说这个Papell Li

23
00:00:42,100 --> 00:00:43,500
lisharin比如说这个

24
00:00:43,533 --> 00:00:44,200
这个字符串

25
00:00:44,200 --> 00:00:46,433
它是假设行数为3的时候

26
00:00:46,433 --> 00:00:47,166
排列是这样的

27
00:00:47,200 --> 00:00:48,033
怎么排呢就是

28
00:00:49,033 --> 00:00:50,266
先往下排pay

29
00:00:50,600 --> 00:00:56,666
像对应的PAYPAYPALISHIRING

30
00:00:56,833 --> 00:00:57,433
它这样排的

31
00:00:57,433 --> 00:00:59,233
就是ZZ z z字形

32
00:01:01,100 --> 00:01:02,266
行数为3的时候是这样的

33
00:01:02,266 --> 00:01:04,733
然后然后他是让我们输出什么呢

34
00:01:04,766 --> 00:01:05,300
就是输出

35
00:01:05,300 --> 00:01:06,800
就是从左往右依次输出

36
00:01:07,566 --> 00:01:12,600
比如说这个就是PAHNAPL SIIGYIR

37
00:01:12,666 --> 00:01:14,966
就是PAHAPLSYIIGYIR

38
00:01:15,600 --> 00:01:17,533
然后就是让我根据这个函数

39
00:01:17,533 --> 00:01:19,100
来生成一个指定函数

40
00:01:19,100 --> 00:01:20,100
变化的一个函数嘛

41
00:01:21,033 --> 00:01:21,966
好基本上题目就是这样的

42
00:01:22,000 --> 00:01:23,266
然后我来分析一下我的解法

43
00:01:23,333 --> 00:01:24,166
呃我的解法

44
00:01:24,600 --> 00:01:25,266
呃我的解法呢

45
00:01:25,266 --> 00:01:27,100
就是嗯只有20多行

46
00:01:27,100 --> 00:01:29,800
但是嗯这里面涉及到了一些

47
00:01:30,733 --> 00:01:32,533
呃我还是想了挺久的

48
00:01:32,533 --> 00:01:34,200
因为首先你这个题目

49
00:01:34,233 --> 00:01:35,666
他是让你一个z z变换

50
00:01:35,933 --> 00:01:37,400
但是他其实里面有很多东西

51
00:01:37,433 --> 00:01:37,966
都是固定的

52
00:01:37,966 --> 00:01:39,300
你可以找到一些规律出来

53
00:01:39,333 --> 00:01:40,600
比如说行数为3的时候

54
00:01:40,866 --> 00:01:42,466
他的中间的间隔肯定是

55
00:01:43,533 --> 00:01:46,033
中间间隔的话就是间隔呃

56
00:01:46,266 --> 00:01:46,933
间隔多少呢

57
00:01:46,933 --> 00:01:48,400
就是但是你看得出来是固定的

58
00:01:48,433 --> 00:01:49,166
然后中间呢

59
00:01:49,433 --> 00:01:51,100
比如说中间的这个竖竖竖下来

60
00:01:51,100 --> 00:01:51,933
这这一个

61
00:01:52,100 --> 00:01:52,933
比如说在中间的时候

62
00:01:52,933 --> 00:01:54,800
他中间肯定是有多一位出来的

63
00:01:55,666 --> 00:01:57,166
然后多具体是多了多少位呢

64
00:01:57,266 --> 00:01:57,800
也是固定的

65
00:01:57,800 --> 00:01:59,000
你也要分析出规律来

66
00:01:59,033 --> 00:02:00,833
这就是我总结出来的一个呃

67
00:02:00,833 --> 00:02:03,166
要这这题应该怎么做的一个核心观点

68
00:02:03,166 --> 00:02:04,100
就是要总结规律

69
00:02:04,666 --> 00:02:06,733
看到固定的就应该用数学归纳法来归

70
00:02:06,766 --> 00:02:08,466
呃总结出来啊

71
00:02:08,733 --> 00:02:10,533
然后我来跟大家说一下

72
00:02:10,533 --> 00:02:11,833
就是我做的笔记啊

73
00:02:11,900 --> 00:02:12,533
我做的草稿

74
00:02:12,533 --> 00:02:13,566
就比如说刚刚那道题

75
00:02:13,700 --> 00:02:16,600
我如果看它的下标来总结规律的话

76
00:02:16,600 --> 00:02:17,700
我觉得是会比较快一点

77
00:02:17,700 --> 00:02:19,566
然后我是用长度作为下标来总结

78
00:02:19,600 --> 00:02:21,833
不是用那个数组的下标做总结

79
00:02:21,833 --> 00:02:23,333
因为数组是从0开始

80
00:02:23,366 --> 00:02:25,200
我觉得有些时候可能会误导我吧

81
00:02:25,266 --> 00:02:25,566
然后

82
00:02:25,600 --> 00:02:28,933
所以说我用这个长度下标作为一个呃

83
00:02:29,533 --> 00:02:30,366
摸索了一个规律

84
00:02:30,400 --> 00:02:31,866
你看PAYP

85
00:02:32,000 --> 00:02:34,166
你看比如说长度是4的话

86
00:02:34,333 --> 00:02:35,400
它就是行

87
00:02:35,400 --> 00:02:36,100
行数为4的话

88
00:02:36,100 --> 00:02:37,166
它就是呃

89
00:02:37,200 --> 00:02:37,866
这里是4

90
00:02:37,933 --> 00:02:41,066
从1到4 然后它到它下一个

91
00:02:41,100 --> 00:02:42,466
就是输出的字母的时候

92
00:02:42,466 --> 00:02:44,233
就是1到7中间隔了6

93
00:02:44,533 --> 00:02:46,866
然后他这a到l这里隔了是4

94
00:02:47,033 --> 00:02:49,733
然后3-5隔了是2246

95
00:02:49,766 --> 00:02:51,166
是不是总结出一个规律来

96
00:02:52,000 --> 00:02:53,333
然后具体这边怎么总结呢

97
00:02:53,533 --> 00:02:54,566
这边这边的总结的话

98
00:02:54,566 --> 00:02:55,733
我们不需要总结这边

99
00:02:55,833 --> 00:02:57,533
比如说这边是246这样子

100
00:02:57,533 --> 00:02:58,666
不需要我们是呃

101
00:02:58,700 --> 00:02:59,266
总结了这边的话

102
00:02:59,266 --> 00:02:59,833
我们就总结

103
00:02:59,966 --> 00:03:02,200
然后只需要其实看到这里的话

104
00:03:02,233 --> 00:03:04,300
我们就可以只需要设两个呃

105
00:03:04,333 --> 00:03:06,233
int int数然后再

106
00:03:06,533 --> 00:03:08,200
一个就是大的一个间隔

107
00:03:08,266 --> 00:03:09,900
比如说这么这么大的一个间隔

108
00:03:10,133 --> 00:03:11,366
在四行里面都有

109
00:03:11,366 --> 00:03:12,500
这种大的间隔就是6

110
00:03:12,933 --> 00:03:14,600
这2到8也是63到9也是6

111
00:03:14,933 --> 00:03:16,233
然后还有一些小的间隔

112
00:03:16,266 --> 00:03:17,433
小的间隔就是这a到l

113
00:03:17,433 --> 00:03:18,100
还有y到a

114
00:03:18,900 --> 00:03:20,700
呃a到l的话就是4嘛

115
00:03:20,700 --> 00:03:22,266
4 它跟它是跟这个行数有关的

116
00:03:22,300 --> 00:03:23,400
比如说4减

117
00:03:23,466 --> 00:03:26,033
就是它的总行数是四

118
00:03:26,100 --> 00:03:27,533
四减去它当前行数2

119
00:03:27,866 --> 00:03:30,033
2的话再乘以一个2就是4

120
00:03:30,300 --> 00:03:32,133
比如说4减3的一一乘以2等于2

121
00:03:32,200 --> 00:03:34,033
所以说3下一个就是5

122
00:03:34,666 --> 00:03:35,400
就这样的意思

123
00:03:35,866 --> 00:03:37,933
你直接根据一个他的串形的一个下标

124
00:03:37,966 --> 00:03:38,866
总结出规律来

125
00:03:38,933 --> 00:03:42,100
然后用这个串形的下标直接写出来

126
00:03:42,366 --> 00:03:44,700
呃输出的那个字符串的一个

127
00:03:44,700 --> 00:03:45,100
对应的

128
00:03:45,133 --> 00:03:46,866
他原来的一个串形的下标的一个规律

129
00:03:47,200 --> 00:03:49,100
这就是这道题的一个整体的思路

130
00:03:49,533 --> 00:03:50,700
呃我还总结了一个

131
00:03:50,700 --> 00:03:51,266
就是5个的

132
00:03:51,300 --> 00:03:52,133
就这样的话

133
00:03:52,166 --> 00:03:53,533
就5个的话就更明显了

134
00:03:53,533 --> 00:03:55,233
就是你看呃

135
00:03:55,733 --> 00:03:56,500
第一行的话

136
00:03:57,100 --> 00:03:58,566
第一个是a是一

137
00:03:58,666 --> 00:04:00,133
下一个就是91-9

138
00:04:00,133 --> 00:04:01,266
隔了8 这边也是隔了8

139
00:04:01,266 --> 00:04:01,966
这边也是隔了8

140
00:04:02,533 --> 00:04:03,200
然后的话

141
00:04:03,233 --> 00:04:04,066
这边就是隔了6

142
00:04:04,566 --> 00:04:06,600
那就是2468

143
00:04:07,100 --> 00:04:09,066
就是刚刚印证了我刚刚那种思想嘛

144
00:04:09,233 --> 00:04:12,300
然后中间的这种就中间的只有一只

145
00:04:12,333 --> 00:04:14,400
会出现多一个一个这种字母出来

146
00:04:14,733 --> 00:04:15,800
所以说呃

147
00:04:16,033 --> 00:04:17,133
只用单纯的加就可以了

148
00:04:17,400 --> 00:04:19,433
然后好知道这些之后

149
00:04:19,433 --> 00:04:20,133
我们来写代码

150
00:04:20,833 --> 00:04:21,400
嗯

151
00:04:22,300 --> 00:04:22,966
嗯写代码的时候

152
00:04:23,000 --> 00:04:23,600
当然呃

153
00:04:23,600 --> 00:04:25,600
你像说你可能想象不到这种呃

154
00:04:25,600 --> 00:04:26,833
边界的情况啊什么的

155
00:04:26,966 --> 00:04:27,800
我也想象不到

156
00:04:28,466 --> 00:04:29,366
嗯我也想象不到

157
00:04:29,366 --> 00:04:30,433
就是我后面加上去的

158
00:04:30,533 --> 00:04:30,833
为什么呢

159
00:04:30,833 --> 00:04:32,233
因为啊当s size等于一

160
00:04:32,266 --> 00:04:33,666
的时候你直接return s就行了

161
00:04:33,933 --> 00:04:35,266
就他他只有一个字母的时候

162
00:04:35,266 --> 00:04:36,100
你怎么这变化

163
00:04:36,166 --> 00:04:37,900
没有必没有没有这变化的必要啊

164
00:04:38,000 --> 00:04:39,533
就直接等于返回s

165
00:04:39,600 --> 00:04:40,933
如果说当他的行数为一的时候

166
00:04:41,133 --> 00:04:42,033
那他只有一一行的话

167
00:04:42,033 --> 00:04:42,500
怎么这变化

168
00:04:42,533 --> 00:04:43,533
直接就是一行过去了

169
00:04:43,533 --> 00:04:44,600
那就是返回s

170
00:04:44,733 --> 00:04:46,300
这两个这两种情况的话

171
00:04:46,333 --> 00:04:47,500
在我这种方式方法里面

172
00:04:47,533 --> 00:04:49,266
都是呃返回的错误结果

173
00:04:49,266 --> 00:04:50,400
然后再加上他是边界情况

174
00:04:50,433 --> 00:04:52,300
所以我后面就把它单独列出来了

175
00:04:52,300 --> 00:04:54,300
然后看给大家看一下

176
00:04:54,333 --> 00:04:55,233
我这个呃

177
00:04:55,266 --> 00:04:56,700
我这个是一个二重循环

178
00:04:56,700 --> 00:04:58,366
但是我为什么不用呃

179
00:04:58,566 --> 00:05:01,533
哈西函数去给它把外层循环给弄掉呢

180
00:05:01,533 --> 00:05:03,366
因为它这是一个呃

181
00:05:03,866 --> 00:05:07,266
他这不是一个查找值的一种呃算法

182
00:05:07,300 --> 00:05:09,433
他这个是负值的一种算法

183
00:05:09,433 --> 00:05:11,266
所以说哈西函数是嗯

184
00:05:11,266 --> 00:05:12,000
可能没有

185
00:05:12,433 --> 00:05:15,133
没有能力去减少这种复杂度啊

186
00:05:16,933 --> 00:05:18,766
然后我们先从呃最外层循环开始看起

187
00:05:18,800 --> 00:05:21,500
最外层循环就是i从从0到呃number rose

188
00:05:21,533 --> 00:05:23,000
就是从从0到这个行数

189
00:05:23,000 --> 00:05:23,733
比如说这个4行

190
00:05:23,900 --> 00:05:24,900
0到这个4行里面

191
00:05:26,000 --> 00:05:27,333
进行一个呃小的循环

192
00:05:27,333 --> 00:05:28,000
就是j等于i

193
00:05:28,033 --> 00:05:30,900
i从就是从i到那个s等于size

194
00:05:30,900 --> 00:05:32,033
为什么z要等于i呢

195
00:05:32,133 --> 00:05:33,866
因为我这一个便利

196
00:05:33,866 --> 00:05:34,033
是

197
00:05:34,033 --> 00:05:36,800
每次代表的是便利第几行的一个元素

198
00:05:36,866 --> 00:05:38,866
比如说i等于0的时候就便利第一行

199
00:05:39,000 --> 00:05:43,033
那z就要从呃S0开始算对吧

200
00:05:43,266 --> 00:05:45,666
所以说然后z v s为什么要小于s size呢

201
00:05:45,700 --> 00:05:47,433
因为我这次每次加的时候

202
00:05:47,433 --> 00:05:48,666
我的步长是不一样的

203
00:05:48,733 --> 00:05:50,366
所以我所以说我这边没有算那个

204
00:05:50,366 --> 00:05:51,400
Z1到底要不要加几

205
00:05:51,800 --> 00:05:54,400
我的步长有些时候是呃啊

206
00:05:54,433 --> 00:05:55,766
好像大部分都是要加这个东西

207
00:05:55,766 --> 00:05:56,133
这个也可以

208
00:05:56,133 --> 00:05:57,200
其实也可以写到这里来

209
00:05:57,266 --> 00:05:59,766
然后我就定义两个数

210
00:06:00,600 --> 00:06:02,533
一个就是我刚刚说那种最长的一个呃

211
00:06:02,566 --> 00:06:03,800
补偿就是呃

212
00:06:03,800 --> 00:06:05,200
在这边在这边提到的一个

213
00:06:05,233 --> 00:06:05,800
这边是6

214
00:06:05,800 --> 00:06:06,633
就是一个最长的补偿

215
00:06:06,666 --> 00:06:08,166
这边2到8是63到9是6

216
00:06:08,266 --> 00:06:09,266
这是一个最长的补偿

217
00:06:09,366 --> 00:06:11,033
然后还有个小步长

218
00:06:11,200 --> 00:06:12,533
最长的步长就是呃

219
00:06:12,766 --> 00:06:14,166
行数减一乘以2嘛

220
00:06:14,266 --> 00:06:14,866
就可以总结出来

221
00:06:14,866 --> 00:06:16,800
就是4-1=33

222
00:06:16,833 --> 00:06:17,500
乘以2=6

223
00:06:17,700 --> 00:06:19,233
就是4行的时候它的最长步长是6

224
00:06:19,400 --> 00:06:20,366
然后呃

225
00:06:20,366 --> 00:06:20,933
中间的

226
00:06:20,966 --> 00:06:22,366
比如说中间的这种小跨度的话

227
00:06:22,366 --> 00:06:23,800
就是呃

228
00:06:24,533 --> 00:06:26,166
行数减去i加一乘以2

229
00:06:27,100 --> 00:06:27,600
你懂我意思吧

230
00:06:27,600 --> 00:06:30,333
就是行数减去i

231
00:06:30,700 --> 00:06:32,533
比如说ISD0行

232
00:06:33,200 --> 00:06:34,233
它这里应该是6嘛

233
00:06:34,366 --> 00:06:35,200
它这里应该是6

234
00:06:35,733 --> 00:06:37,100
那行数是4行

235
00:06:37,200 --> 00:06:38,600
那对应就是2乘以3等于6

236
00:06:38,600 --> 00:06:39,600
所以说4要减去一

237
00:06:39,800 --> 00:06:41,633
那这个一本来是第一行的意思

238
00:06:41,666 --> 00:06:43,333
但是这个i是属于从0开始的

239
00:06:43,333 --> 00:06:43,900
所以要加一

240
00:06:43,900 --> 00:06:46,000
所以说就相当于行数减去呃

241
00:06:46,233 --> 00:06:47,433
总行数减去当前行数

242
00:06:47,433 --> 00:06:48,066
然后再乘以2

243
00:06:48,100 --> 00:06:48,400
就是一个

244
00:06:48,400 --> 00:06:50,733
中间的一个跨度就是呃642

245
00:06:51,833 --> 00:06:52,666
然后还有一个判定

246
00:06:52,700 --> 00:06:53,600
就是说嗯

247
00:06:53,600 --> 00:06:56,266
如果说他他减去一的话等于I的话

248
00:06:56,300 --> 00:06:58,266
我就直接让他的一个中间跨度

249
00:06:58,266 --> 00:06:59,600
等于他的这个最长跨度

250
00:06:59,600 --> 00:06:59,933
为什么呢

251
00:06:59,966 --> 00:07:01,666
因为我我这个算法的话

252
00:07:01,700 --> 00:07:03,300
还需要考虑到就是最下面这一行

253
00:07:03,533 --> 00:07:04,200
最下面这一行的话

254
00:07:04,200 --> 00:07:06,433
如果说我不不用这样的一个的话

255
00:07:06,433 --> 00:07:08,733
就可能就会导致呃MIDO的话

256
00:07:08,766 --> 00:07:10,900
它就等于一个最大的函数减去

257
00:07:10,900 --> 00:07:12,600
函数减去一个最大的函数加

258
00:07:12,600 --> 00:07:15,866
一嗯函数减一加一就是就等于0了

259
00:07:15,900 --> 00:07:16,800
MIDO就会等于0

260
00:07:17,000 --> 00:07:19,333
所以说就会导致呃多了一个

261
00:07:20,000 --> 00:07:20,866
就在这边会多一

262
00:07:20,866 --> 00:07:23,233
多选出一个呃错误的字母出来

263
00:07:23,666 --> 00:07:25,966
然后上面这些都判断完了下

264
00:07:25,966 --> 00:07:26,966
接下来就是呃

265
00:07:27,000 --> 00:07:28,266
我的一个主要的一个

266
00:07:28,700 --> 00:07:30,933
主要的一个主要的一个呃算法了

267
00:07:30,966 --> 00:07:33,200
就是当最长的跨度

268
00:07:33,233 --> 00:07:34,400
等于中间的跨度的时候

269
00:07:34,433 --> 00:07:36,500
就是我这边两个算出来是相等的时候

270
00:07:37,600 --> 00:07:38,300
就是什么情况呢

271
00:07:38,300 --> 00:07:39,233
就是呃

272
00:07:39,266 --> 00:07:41,233
在第一行的时候可以算出来是相等的

273
00:07:41,566 --> 00:07:43,600
然后我当初想的话就是呃

274
00:07:43,933 --> 00:07:45,633
我想的话最后一行应该是相等的

275
00:07:46,233 --> 00:07:46,500
所以说

276
00:07:46,533 --> 00:07:48,233
我就是在前面这里就把它加上去

277
00:07:48,233 --> 00:07:48,800
相等了

278
00:07:49,400 --> 00:07:50,733
所以说就是强强行使

279
00:07:50,733 --> 00:07:52,633
它就是在等于呃

280
00:07:53,200 --> 00:07:54,133
就是在i等于0

281
00:07:54,133 --> 00:07:55,800
和这个numbers减一的时候

282
00:07:56,000 --> 00:07:56,733
其实可以优化

283
00:07:56,766 --> 00:07:57,466
把这两行优化掉

284
00:07:57,466 --> 00:07:59,166
然后再把这个条件改成呃

285
00:07:59,200 --> 00:08:01,766
i等于numbers减一或者等于0的时候

286
00:08:01,900 --> 00:08:03,166
啊就取就取这一个

287
00:08:03,400 --> 00:08:04,266
为什么取这个呢因为

288
00:08:05,466 --> 00:08:06,600
啊就是这个是目标

289
00:08:06,600 --> 00:08:07,200
目标支付算

290
00:08:07,233 --> 00:08:07,800
目标支付算

291
00:08:07,800 --> 00:08:10,633
取当前的z下标加进去

292
00:08:10,666 --> 00:08:13,166
然后z就跨过这一个步长

293
00:08:13,833 --> 00:08:14,233
这种情况

294
00:08:14,266 --> 00:08:16,433
就是对于第一行和最后一行来做的

295
00:08:16,600 --> 00:08:17,933
然后剩余的就是一个普通情况

296
00:08:17,966 --> 00:08:18,866
就是中间这些行

297
00:08:19,233 --> 00:08:19,800
中间这些行呢

298
00:08:19,800 --> 00:08:21,033
更简单就是呃

299
00:08:21,100 --> 00:08:21,933
会多了一个步骤

300
00:08:21,933 --> 00:08:23,100
就是说嗯

301
00:08:23,100 --> 00:08:24,266
z加上它的一个中间

302
00:08:24,300 --> 00:08:25,000
中间跨度

303
00:08:25,033 --> 00:08:26,366
然后再如果说

304
00:08:26,733 --> 00:08:28,133
如果说j加上它的中间跨度

305
00:08:28,133 --> 00:08:29,600
小于总长度的话

306
00:08:29,800 --> 00:08:30,533
我们就加

307
00:08:30,666 --> 00:08:30,966
什么意思呢

308
00:08:30,966 --> 00:08:33,133
就是有可能就是在呃

309
00:08:34,100 --> 00:08:36,833
在这个j就是这个长

310
00:08:36,900 --> 00:08:38,500
这个当前便利这个地方

311
00:08:38,933 --> 00:08:40,633
如果说它加上一个中间跨度

312
00:08:41,800 --> 00:08:42,533
它大于了

313
00:08:42,566 --> 00:08:43,800
就说明他下一次是应该

314
00:08:43,833 --> 00:08:45,166
是不会变离到这个地方的

315
00:08:45,566 --> 00:08:46,733
就比如他这个中间跨度是2

316
00:08:47,233 --> 00:08:48,800
他这个中间跨度是2

317
00:08:48,800 --> 00:08:49,366
那如果说

318
00:08:50,966 --> 00:08:51,833
他他在家的话

319
00:08:53,600 --> 00:08:54,400
他他在加的话

320
00:08:54,433 --> 00:08:55,900
就是就呃

321
00:08:56,000 --> 00:08:56,666
不应该这么举例啊

322
00:08:56,700 --> 00:08:57,566
就是呃

323
00:08:57,600 --> 00:08:59,066
他每次会加一个最最长的跨度

324
00:08:59,100 --> 00:09:00,466
比如说如果说他这一次

325
00:09:00,666 --> 00:09:02,500
他这一次加了呃

326
00:09:02,700 --> 00:09:03,133
就在这他

327
00:09:03,166 --> 00:09:04,366
他一般是会在这种情况

328
00:09:04,366 --> 00:09:05,533
然后再呃加

329
00:09:05,533 --> 00:09:05,933
加上这个

330
00:09:05,966 --> 00:09:06,800
然后再加上这个

331
00:09:07,033 --> 00:09:07,666
然后下一次的话

332
00:09:07,666 --> 00:09:08,400
他就他就会

333
00:09:08,533 --> 00:09:09,866
他就会从这里跳过一个步长

334
00:09:09,900 --> 00:09:10,566
跳到这里来

335
00:09:11,333 --> 00:09:12,233
然后他就会呃

336
00:09:12,233 --> 00:09:13,966
如果说他加上一个最小的跨度的话

337
00:09:14,033 --> 00:09:14,933
他是大于这个的话

338
00:09:14,933 --> 00:09:15,933
就没有必要加这个了

339
00:09:16,433 --> 00:09:17,666
然后为什么你就你就会想

340
00:09:17,700 --> 00:09:18,933
为什么他他不会走这里呢

341
00:09:18,933 --> 00:09:20,733
因为因为我是从从从

342
00:09:20,800 --> 00:09:22,633
我一般都是从从这里开始

343
00:09:22,666 --> 00:09:23,366
从这里开始

344
00:09:23,533 --> 00:09:24,700
然后如果说是一般情况的话

345
00:09:24,700 --> 00:09:26,100
我会把当前的这个字母

346
00:09:26,100 --> 00:09:27,300
还有这个字母给加上

347
00:09:27,533 --> 00:09:29,533
然后再从这边跨到这边来

348
00:09:29,566 --> 00:09:31,300
然后再算这个h和r

349
00:09:31,600 --> 00:09:33,266
然后再从这边跨到这边来

350
00:09:33,700 --> 00:09:34,300
跨到这边来的时候

351
00:09:34,333 --> 00:09:35,100
一般就是啊

352
00:09:35,100 --> 00:09:36,833
这个z就会大于这个SS点size

353
00:09:36,866 --> 00:09:38,000
所以说就会跳出去这个循环

354
00:09:38,033 --> 00:09:38,700
所以说呃

355
00:09:38,700 --> 00:09:39,833
这边是没有一个越界的

356
00:09:39,866 --> 00:09:41,000
越界的情况的存在

357
00:09:41,133 --> 00:09:41,466
所以说

358
00:09:41,466 --> 00:09:43,933
最后他就会呃出这样的一个测试结果

359
00:09:44,266 --> 00:09:44,933
测试结果的话

360
00:09:44,933 --> 00:09:46,800
它用时一般都是零零零

361
00:09:47,200 --> 00:09:48,433
因为因为太快了

362
00:09:49,600 --> 00:09:51,100
好这就是我今天的一个n

363
00:09:51,133 --> 00:09:52,300
字形变化的一个体解

364
00:09:52,800 --> 00:09:53,366
呃

365
00:09:54,033 --> 00:09:55,500
9分钟之前提交的

366
00:09:56,733 --> 00:09:57,700
非常快很开心

367
00:09:59,100 --> 00:09:59,833
好谢谢大家

