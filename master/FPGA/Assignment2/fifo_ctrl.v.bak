 // fifo_ctrl.v

/*
 * fifo ctrl file
 * ---------------------
 * For: University of Leeds
 * Date: 24/04/2024
 * Author: Junnan Liu
 * ID: 201715540
 *
 * Description
 * ------------
 * The module is witten for the FIFO control.
 * 122
 *
 */
 
//============================================================================
//                              Module definition
//============================================================================

module fifo_ctrl
	#( ADDR_WIDTH = 4) // address width
(
	// clock and reset
	input 	wire clk, 	reset,
	// read or write
	input 	wire rd, 	wr,
	// empty or full
	output 	wire empty, full,
	// write address
	output 	wire [ADDR_WIDTH-1:0] w_addr,
	// read address and read next address
	output 	wire [ADDR_WIDTH-1:0] r_addr, r_addr_next
);

//============================================================================
//                              Variable Definition
//============================================================================
	// signal declaration
	reg [ADDR_WIDTH-1:0] w_ptr_reg , w_ptr_next, w_ptr_succ;
	reg [ADDR_WIDTH-1:0] r_ptr_reg, r_ptr_next, r_ptr_succ;
	reg full_reg, empty_reg, full_next, empty_next;
	
	
//============================================================================
//                              State Machine
//============================================================================

	// body
	// fifo control logic
	// registers for status and read and write pointers
	always @(posedge clk, posedge reset) begin
		if(reset) begin
			w_ptr_reg 	<= 0;
			r_ptr_reg 	<= 0;
			full_reg 	<= 1'b0;
			empty_reg 	<= 1'b1;
		end else begin
			w_ptr_reg 	<= w_ptr_next;
			r_ptr_reg 	<= r_ptr_next;
			full_reg 	<= full_next;
			empty_reg 	<= empty_next;
		end
	end
	
	// next_state logic for read and write pointers
	always  @* begin
		// successive pointer values
		w_ptr_succ 	= w_ptr_reg + 1;
		r_ptr_succ 	= r_ptr_reg + 1;
		// default: keep old values
		w_ptr_next 	= w_ptr_reg;
		r_ptr_next 	= r_ptr_reg;
		full_next 	= full_reg;
		empty_next 	= empty_reg;
		case ({wr,rd}) 
			2'b01: begin
				if(!empty_reg) begin
					r_ptr_next 		= r_ptr_succ;
					full_next 		= 1'b0;
					if(r_ptr_succ 	== w_ptr_reg) begin
						empty_next 	= 1'b1;
					end
				end
			end
			2'b10: begin
				if(!full_reg) begin
					w_ptr_next 		= w_ptr_succ;
					empty_next 		= 1'b0;
					if(w_ptr_succ 	== r_ptr_reg) begin
						full_next 	= 1'b1;
					end
				end
			end
			2'b11: begin
				w_ptr_next = w_ptr_succ;
				empty_next = r_ptr_succ;
			end
		endcase
	end
	
	// output
	assign w_addr 		= w_ptr_reg;
	assign r_addr 		= r_ptr_reg;
	assign r_addr_next 	= r_ptr_next;
	assign full 		= full_reg;
	assign empty 		= empty_reg;
endmodule